<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Neural Streak ‚Äî R√©entra√Æne ton cerveau</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        :root {
            --bg-deep: #05050a; --bg-primary: #0a0a12; --bg-secondary: #10101c;
            --bg-card: #16162a; --bg-elevated: #1c1c38;
            --cyan: #00ffd5; --magenta: #ff2d92; --yellow: #ffd000;
            --purple: #a855f7; --orange: #ff6b2c; --blue: #3b82f6;
            --green: #22c55e; --red: #ef4444;
            --text-primary: #fff; --text-secondary: #a0a0b8; --text-muted: #606078;
            --font-display: 'Outfit', sans-serif; --font-mono: 'JetBrains Mono', monospace;
            --radius-sm: 12px; --radius-md: 20px; --radius-lg: 28px;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        html, body, #root { height: 100%; width: 100%; overflow-x: hidden; }
        body { font-family: var(--font-display); background: var(--bg-deep); color: var(--text-primary); }
        
        @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes scaleIn { from { opacity: 0; transform: scale(0.9); } to { opacity: 1; transform: scale(1); } }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-8px); } 75% { transform: translateX(8px); } }
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
        @keyframes gradientShift { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }
        @keyframes glow { 0%, 100% { box-shadow: 0 0 20px currentColor; } 50% { box-shadow: 0 0 40px currentColor; } }
        
        .fadeIn { animation: fadeIn 0.4s ease-out forwards; }
        .scaleIn { animation: scaleIn 0.3s ease-out forwards; }
        .shake { animation: shake 0.4s ease-in-out; }
        .pulse { animation: pulse 0.3s ease-out; }
        
        .gradient-text {
            background: linear-gradient(135deg, var(--cyan) 0%, var(--purple) 50%, var(--magenta) 100%);
            background-size: 200% 200%; -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            background-clip: text; animation: gradientShift 4s ease infinite;
        }
        
        .glass { background: rgba(22, 22, 42, 0.8); backdrop-filter: blur(20px); border: 1px solid rgba(255,255,255,0.05); border-radius: var(--radius-lg); }
        
        .btn {
            display: inline-flex; align-items: center; justify-content: center; gap: 10px;
            padding: 16px 32px; border-radius: var(--radius-lg); font-family: var(--font-display);
            font-weight: 600; font-size: 1rem; border: none; cursor: pointer; transition: all 0.2s ease;
        }
        .btn-primary {
            background: linear-gradient(135deg, var(--cyan) 0%, var(--purple) 50%, var(--magenta) 100%);
            background-size: 200% 200%; color: var(--bg-deep); animation: gradientShift 4s ease infinite;
        }
        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 0 40px rgba(0,255,213,0.3); }
        .btn-secondary { background: var(--bg-elevated); color: var(--text-primary); border: 1px solid rgba(255,255,255,0.1); }
        .btn-secondary:hover { border-color: var(--cyan); }
        .btn-ghost { background: transparent; color: var(--text-secondary); padding: 12px 16px; }
        .btn-ghost:hover { color: var(--text-primary); }
        
        .btn-option {
            width: 100%; padding: 18px 24px; background: var(--bg-card); border: 2px solid transparent;
            border-radius: var(--radius-md); color: var(--text-primary); font-size: 1rem;
            text-align: left; transition: all 0.2s ease; cursor: pointer;
        }
        .btn-option:hover { border-color: var(--cyan); background: var(--bg-elevated); }
        .btn-option.correct { border-color: var(--green); background: rgba(34,197,94,0.15); }
        .btn-option.wrong { border-color: var(--red); background: rgba(239,68,68,0.15); }
        .btn-option:disabled { opacity: 0.6; cursor: default; }
        
        .progress-bar { width: 100%; height: 6px; background: var(--bg-card); border-radius: 3px; overflow: hidden; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, var(--cyan), var(--purple)); transition: width 0.3s ease; }
        
        .grid-bg {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 0;
            background: radial-gradient(ellipse at 50% 0%, rgba(0,255,213,0.06) 0%, transparent 50%),
                linear-gradient(rgba(0,255,213,0.015) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0,255,213,0.015) 1px, transparent 1px);
            background-size: 100% 100%, 50px 50px, 50px 50px;
        }
        
        .cat-memory { --cat: var(--cyan); }
        .cat-critical { --cat: var(--magenta); }
        .cat-semantic { --cat: var(--purple); }
        .cat-ownership { --cat: var(--yellow); }
        .cat-linguistic { --cat: var(--orange); }
        .cat-executive { --cat: var(--blue); }
        .cat-creative { --cat: var(--green); }
        .cat-engagement { --cat: var(--red); }
    </style>
</head>
<body>
    <div class="grid-bg"></div>
    <div id="root"></div>
    <script type="text/babel">
const { useState, useEffect, useCallback, useRef } = React;

// ===== UTILITIES =====
const shuffle = arr => { const a = [...arr]; for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]]; } return a; };
const pick = arr => arr[Math.floor(Math.random() * arr.length)];
const pickN = (arr, n) => shuffle(arr).slice(0, n);
const sleep = ms => new Promise(r => setTimeout(r, ms));
const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

const COLORS = ['cyan', 'magenta', 'yellow', 'purple', 'orange', 'green'];
const COLOR_HEX = { cyan: '#00ffd5', magenta: '#ff2d92', yellow: '#ffd000', purple: '#a855f7', orange: '#ff6b2c', green: '#22c55e' };

// ===== GAME DATA =====
const CATEGORIES = [
    { id: 'memory', name: 'M√©moire de Travail', icon: 'üß†', color: 'cat-memory', stat: '-50%', statDesc: 'connectivit√© c√©r√©brale', games: ['sequence', 'nback', 'chunking', 'updating'] },
    { id: 'critical', name: 'Pens√©e Critique', icon: 'üîç', color: 'cat-critical', stat: '-36%', statDesc: 'pens√©e critique (Gerlich)', games: ['hallucination', 'fallacy', 'trilemma'] },
    { id: 'semantic', name: 'M√©moire S√©mantique', icon: 'üìö', color: 'cat-semantic', stat: '72%', statDesc: 'amn√©sie num√©rique', games: ['causal', 'recall'] },
    { id: 'ownership', name: 'Sentiment d\'Auteur', icon: '‚úçÔ∏è', color: 'cat-ownership', stat: '83%', statDesc: 'perte ownership', games: ['humanai', 'constraints'] },
    { id: 'linguistic', name: 'Comp√©tences Linguistiques', icon: 'üí¨', color: 'cat-linguistic', stat: '5.3x', statDesc: 'rigidit√© syntaxique', games: ['syntax', 'cliche', 'metaphor'] },
    { id: 'executive', name: 'Fonctions Ex√©cutives', icon: 'üéØ', color: 'cat-executive', stat: '+23%', statDesc: 'perf. avec entra√Ænement', games: ['sequencing', 'resources'] },
    { id: 'creative', name: 'Cr√©ativit√©', icon: 'üí°', color: 'cat-creative', stat: '‚àû', statDesc: 'potentiel cr√©atif', games: ['associations', 'uchronia'] },
    { id: 'engagement', name: 'Engagement Neural', icon: '‚ö°', color: 'cat-engagement', stat: '0%', statDesc: 'effort avec ChatGPT', games: ['reaction', 'focus'] }
];

const GAMES = {
    sequence: { name: 'S√©quence Visuelle', desc: 'M√©morise et reproduis des s√©quences', icon: 'üé®' },
    nback: { name: 'N-Back', desc: 'Identifie les r√©p√©titions N √©tapes avant', icon: 'üîÑ' },
    chunking: { name: 'Chunking', desc: 'Regroupe pour mieux m√©moriser', icon: 'üì¶' },
    updating: { name: 'Liste Vivante', desc: 'Modifie une liste en temps r√©el', icon: 'üìù' },
    hallucination: { name: 'Spot the Hallucination', desc: 'D√©tecte les erreurs de l\'IA', icon: 'üé≠' },
    fallacy: { name: 'Bullshit Detector', desc: 'Identifie les sophismes', icon: 'üö®' },
    trilemma: { name: 'Vrai / Faux / ?', desc: 'Distingue le v√©rifiable', icon: '‚ùì' },
    causal: { name: 'Cha√Æne Causale', desc: 'Reconstruis les liens cause-effet', icon: 'üîó' },
    recall: { name: 'Rappel Diff√©r√©', desc: 'M√©morise puis rappelle apr√®s d√©lai', icon: 'üß©' },
    humanai: { name: 'Humain ou IA ?', desc: 'Identifie l\'origine des textes', icon: 'ü§ñ' },
    constraints: { name: 'Contraintes', desc: 'Construis avec des r√®gles impos√©es', icon: 'üé≤' },
    syntax: { name: 'Puzzle Syntaxique', desc: 'Reconstruis les phrases', icon: 'üß±' },
    cliche: { name: 'Langue Pure', desc: 'D√©tecte les clich√©s IA', icon: '‚ú®' },
    metaphor: { name: 'M√©taphores', desc: 'Choisis la meilleure analogie', icon: 'üåà' },
    sequencing: { name: 'Remets dans l\'ordre', desc: 'Ordonne les √©tapes logiques', icon: 'üìä' },
    resources: { name: 'Gestionnaire', desc: 'Optimise les ressources', icon: 'üíé' },
    associations: { name: 'Connexions Improbables', desc: 'Relie des concepts √©loign√©s', icon: 'üîÄ' },
    uchronia: { name: 'Et si... ?', desc: 'Imagine les cons√©quences alternatives', icon: 'üåÄ' },
    reaction: { name: 'Go / No-Go', desc: 'R√©agis vite et bien', icon: '‚ö°' },
    focus: { name: 'Focus Soutenu', desc: 'D√©tecte les changements subtils', icon: 'üëÅÔ∏è' }
};

// ===== GAME CONTENT DATA =====
const HALLUCINATION_DATA = [
    { text: "La Tour Eiffel, construite en 1889, mesure 324 m√®tres. Elle devait √™tre d√©mont√©e apr√®s 20 ans. Elle accueille environ 7 millions de visiteurs par an.", hasError: false },
    { text: "Le c≈ìur humain bat environ 100 000 fois par jour. Il pompe 5 litres de sang par minute et poss√®de 6 cavit√©s : deux oreillettes et quatre ventricules.", hasError: true, error: "Le c≈ìur a 4 cavit√©s, pas 6" },
    { text: "Python est un langage cr√©√© par Guido van Rossum en 1991. Le nom vient du groupe comique britannique Monty Python.", hasError: false },
    { text: "La photosynth√®se permet aux plantes de convertir le CO2 en glucose gr√¢ce √† la lumi√®re. Ce processus se d√©roule dans les mitochondries.", hasError: true, error: "Dans les chloroplastes, pas les mitochondries" },
    { text: "Mozart a compos√© plus de 600 ≈ìuvres durant ses 35 ans de vie. Il a commenc√© √† composer d√®s l'√¢ge de 5 ans.", hasError: false },
    { text: "L'ADN humain contient environ 3 milliards de paires de bases et code pour environ 200 000 g√®nes.", hasError: true, error: "Environ 20 000 g√®nes, pas 200 000" },
    { text: "Van Gogh a peint 'La Nuit √©toil√©e' en 1889. Durant sa vie, il a vendu des centaines de tableaux et √©tait tr√®s reconnu.", hasError: true, error: "Il n'a vendu qu'un seul tableau de son vivant" },
    { text: "Le Bitcoin a √©t√© cr√©√© en 2009 par Satoshi Nakamoto. La premi√®re transaction a permis d'acheter deux pizzas pour 10 000 BTC.", hasError: false }
];

const FALLACY_DATA = [
    { text: "Tous les experts sont d'accord, donc tu dois l'accepter sans questionner.", fallacy: "Appel √† l'autorit√©", options: ["Appel √† l'autorit√©", "Homme de paille", "Faux dilemme", "Pente glissante"] },
    { text: "Si on autorise le t√©l√©travail, bient√¥t plus personne ne viendra et l'entreprise fera faillite.", fallacy: "Pente glissante", options: ["Ad hominem", "Pente glissante", "Faux dilemme", "G√©n√©ralisation"] },
    { text: "Soit tu es avec nous, soit tu es contre nous.", fallacy: "Faux dilemme", options: ["Faux dilemme", "Homme de paille", "Appel √† l'√©motion", "Circulaire"] },
    { text: "Mon grand-p√®re a fum√© toute sa vie et v√©cu jusqu'√† 95 ans. Le tabac n'est pas dangereux.", fallacy: "G√©n√©ralisation h√¢tive", options: ["Appel √† la tradition", "G√©n√©ralisation h√¢tive", "Post hoc", "Biais survivant"] },
    { text: "Tu ne peux pas critiquer mon projet, tu n'as m√™me pas de dipl√¥me.", fallacy: "Ad hominem", options: ["Ad hominem", "Appel √† l'autorit√©", "Homme de paille", "Tu quoque"] },
    { text: "On a toujours fait comme √ßa, donc c'est la bonne m√©thode.", fallacy: "Appel √† la tradition", options: ["Appel √† la tradition", "Circulaire", "Appel √† la nature", "Confirmation"] }
];

const TRILEMMA_DATA = [
    { statement: "L'eau bout √† 100¬∞C au niveau de la mer.", answer: "true" },
    { statement: "La population mondiale atteindra 10 milliards en 2050.", answer: "unknown" },
    { statement: "Napol√©on est mort en 1821 √† Sainte-H√©l√®ne.", answer: "true" },
    { statement: "L'IA sera plus intelligente que l'humain d'ici 2030.", answer: "unknown" },
    { statement: "Le Soleil tourne autour de la Terre.", answer: "false" },
    { statement: "Shakespeare a √©crit 'Don Quichotte'.", answer: "false" },
    { statement: "Le stress chronique affecte le syst√®me immunitaire.", answer: "true" },
    { statement: "Les dauphins sont les animaux les plus intelligents.", answer: "unknown" }
];

const HUMAN_AI_DATA = [
    { text: "Franchement, j'en ai marre de ces r√©unions qui servent √† rien. Trois heures pour d√©cider de la couleur d'un bouton.", author: "human" },
    { text: "Il est important de noter que les r√©unions constituent un √©l√©ment essentiel de la collaboration. Cependant, leur efficacit√© peut √™tre optimis√©e.", author: "ai" },
    { text: "Le caf√© de la machine du 3√®me est d√©gueulasse mais au moins y'a jamais la queue. Choix strat√©gique.", author: "human" },
    { text: "En conclusion, plusieurs axes d'am√©lioration peuvent √™tre envisag√©s pour optimiser ce processus de mani√®re significative.", author: "ai" },
    { text: "Ma grand-m√®re dit toujours que pour r√©ussir un g√¢teau, faut pas ouvrir le four pendant 20 minutes. Elle a raison.", author: "human" },
    { text: "La cuisson des p√¢tisseries n√©cessite une attention particuli√®re. Il est recommand√© de suivre les instructions avec pr√©cision.", author: "ai" }
];

const CAUSAL_DATA = [
    { event: "Hausse des taux d'int√©r√™t", steps: ["Banque centrale augmente les taux", "Emprunts plus chers", "M√©nages empruntent moins", "Consommation ralentit", "Inflation diminue"] },
    { event: "D√©forestation massive", steps: ["Coupe des arbres", "Perte d'habitat", "√ârosion des sols", "Moins d'absorption CO2", "Changement climatique"] },
    { event: "Produit viral", steps: ["Innovation produit", "Premiers enthousiastes", "Bouche-√†-oreille", "Couverture m√©diatique", "Adoption massive"] }
];

const SYNTAX_DATA = [
    { fragments: ["malgr√©", "r√©ussi", "il a", "les obstacles", "son objectif"], correct: [2, 0, 3, 1, 4] },
    { fragments: ["plus", "travaille", "on", "apprend", "on", "plus"], correct: [0, 2, 1, 5, 4, 3] },
    { fragments: ["jamais", "n'est", "trop", "tard", "apprendre", "il", "pour"], correct: [5, 1, 0, 2, 3, 6, 4] }
];

const CLICHE_DATA = [
    { text: "Il est important de noter que ce projet pr√©sente des d√©fis significatifs.", hasCliche: true, cliches: ["Il est important de noter", "d√©fis significatifs"] },
    { text: "L'√©quipe a travaill√© dur pour livrer √† temps.", hasCliche: false },
    { text: "En conclusion, plusieurs axes d'am√©lioration peuvent √™tre envisag√©s.", hasCliche: true, cliches: ["En conclusion", "axes d'am√©lioration", "peuvent √™tre envisag√©s"] },
    { text: "Nous avons rat√© la deadline, il faut revoir notre planning.", hasCliche: false },
    { text: "Cette solution permet d'optimiser les processus de mani√®re significative.", hasCliche: true, cliches: ["permet d'optimiser", "de mani√®re significative"] }
];

const METAPHOR_DATA = [
    { concept: "La procrastination", options: ["Un compte √† rebours invers√©", "Des sables mouvants", "Une avalanche en pr√©paration", "Un √©lastique tendu"], best: 2 },
    { concept: "L'apprentissage", options: ["Construire un pont", "Remplir un verre", "Sculpter une statue", "Allumer des lumi√®res"], best: 2 },
    { concept: "La cr√©ativit√©", options: ["Un muscle", "Une rivi√®re", "Un jardin sauvage", "Un feu de camp"], best: 2 },
    { concept: "L'√©chec", options: ["Un mur", "Un tremplin", "Une le√ßon", "Un GPS recalculant"], best: 1 }
];

const SEQUENCE_DATA = [
    { title: "Faire un caf√©", steps: ["Remplir le r√©servoir", "Mettre le caf√©", "Allumer la machine", "Attendre", "Verser"] },
    { title: "Envoyer un email pro", steps: ["Ouvrir le client", "R√©diger l'objet", "√âcrire le message", "V√©rifier destinataires", "Envoyer"] },
    { title: "R√©soudre un bug", steps: ["Reproduire le bug", "Identifier la cause", "√âcrire le fix", "Tester", "D√©ployer"] },
    { title: "Pr√©parer une pr√©sentation", steps: ["D√©finir l'objectif", "Structurer le plan", "Cr√©er les slides", "R√©p√©ter", "Pr√©senter"] }
];

const ASSOCIATION_DATA = [
    { word1: "Glacier", word2: "Startup", links: ["Mouvement lent vs rapide", "Fondation solide n√©cessaire", "Peut s'effondrer brutalement"] },
    { word1: "Biblioth√®que", word2: "Jungle", links: ["Exploration n√©cessaire", "Tr√©sors cach√©s", "Peut se perdre facilement"] },
    { word1: "Horloge", word2: "Rivi√®re", links: ["Flux continu", "Une seule direction", "Impossible √† remonter"] },
    { word1: "Orchestre", word2: "√âquipe projet", links: ["Besoin d'harmonie", "Un chef coordonne", "Chacun sa partition"] }
];

const UCHRONIA_DATA = [
    { scenario: "Et si Internet n'avait jamais exist√© ?", consequences: ["Journaux papier dominants", "Commerce local", "Biblioth√®ques essentielles", "Pas de t√©l√©travail"], absurd: "Les poissons auraient conquis la Terre" },
    { scenario: "Et si les humains hibernaient ?", consequences: ["√âconomie saisonni√®re", "Chambres d'hibernation", "Pas de f√™tes d'hiver", "R√©serves vitales"], absurd: "Les voitures auraient des roues carr√©es" },
    { scenario: "Et si l'√©criture n'existait pas ?", consequences: ["Tradition orale dominante", "Contrats verbaux", "M√©moire d√©velopp√©e", "Histoire par griots"], absurd: "Les arbres parleraient fran√ßais" }
];
// ===== SHARED COMPONENTS =====

const Header = ({ title, subtitle, onBack, lives, score, level, timer, progress }) => (
    <div style={{ padding: '16px 20px', borderBottom: '1px solid rgba(255,255,255,0.05)' }}>
        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: progress !== undefined ? 12 : 0 }}>
            {onBack ? <button onClick={onBack} className="btn-ghost">‚Üê Retour</button> : <div style={{ width: 80 }} />}
            <div style={{ textAlign: 'center', flex: 1 }}>
                {title && <h1 style={{ fontSize: '1.1rem', fontWeight: 700 }}>{title}</h1>}
                {subtitle && <p style={{ fontSize: '0.8rem', color: 'var(--text-muted)' }}>{subtitle}</p>}
            </div>
            <div style={{ width: 80 }} />
        </div>
        {(lives !== undefined || score !== undefined || level !== undefined || timer !== undefined) && (
            <div style={{ display: 'flex', justifyContent: 'center', gap: 24, marginBottom: 8 }}>
                {lives !== undefined && <Stat label="VIES" value={'‚ù§Ô∏è'.repeat(Math.max(0, lives))} />}
                {score !== undefined && <Stat label="SCORE" value={score} color="var(--yellow)" />}
                {level !== undefined && <Stat label="NIVEAU" value={level} color="var(--cyan)" />}
                {timer !== undefined && <Stat label="TEMPS" value={`${timer}s`} color={timer <= 5 ? 'var(--red)' : 'var(--orange)'} />}
            </div>
        )}
        {progress !== undefined && <div className="progress-bar"><div className="progress-fill" style={{ width: `${progress}%` }} /></div>}
    </div>
);

const Stat = ({ label, value, color }) => (
    <div style={{ textAlign: 'center' }}>
        <div style={{ fontSize: '1.3rem', fontWeight: 700, color: color || 'var(--text-primary)' }}>{value}</div>
        <div style={{ fontSize: '0.65rem', color: 'var(--text-muted)', fontFamily: 'var(--font-mono)' }}>{label}</div>
    </div>
);

const Card = ({ children, style = {} }) => (
    <div className="glass fadeIn" style={{ padding: 24, margin: '0 20px', ...style }}>{children}</div>
);

const OptionBtn = ({ children, onClick, disabled, correct, wrong, selected, style = {} }) => {
    let cls = 'btn-option';
    if (correct) cls += ' correct';
    if (wrong) cls += ' wrong';
    return <button className={cls} onClick={onClick} disabled={disabled} style={{ ...style, opacity: disabled && !correct && !wrong ? 0.5 : 1 }}>{children}</button>;
};

const Feedback = ({ type, message }) => {
    const colors = { success: 'var(--green)', error: 'var(--red)', info: 'var(--cyan)' };
    const icons = { success: '‚úì', error: '‚úó', info: '‚Ñπ' };
    return (
        <div className="scaleIn" style={{
            display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 12,
            padding: '14px 20px', borderRadius: 'var(--radius-md)', marginTop: 16,
            background: `${colors[type]}15`, border: `2px solid ${colors[type]}`, color: colors[type], fontWeight: 600
        }}>
            <span style={{ fontSize: '1.3rem' }}>{icons[type]}</span>{message}
        </div>
    );
};

const ResultScreen = ({ score, maxScore, level, stats, onRetry, onBack }) => {
    const pct = maxScore ? Math.round((score / maxScore) * 100) : 0;
    const emoji = pct >= 90 ? 'üèÜ' : pct >= 70 ? 'üéØ' : pct >= 50 ? 'üí™' : 'üîÑ';
    const msg = pct >= 90 ? 'Exceptionnel !' : pct >= 70 ? 'Bien jou√© !' : pct >= 50 ? 'Pas mal !' : 'Continue !';
    
    useEffect(() => {
        const saved = JSON.parse(localStorage.getItem('neural_user') || '{}');
        const today = new Date().toDateString();
        const newStreak = saved.lastPlayed === today ? saved.streak : (saved.streak || 0) + 1;
        localStorage.setItem('neural_user', JSON.stringify({ 
            ...saved, streak: newStreak, totalScore: (saved.totalScore || 0) + score, lastPlayed: today 
        }));
    }, [score]);
    
    return (
        <div style={{ minHeight: '100vh', display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', padding: 20 }}>
            <div className="scaleIn" style={{ fontSize: '5rem', marginBottom: 16 }}>{emoji}</div>
            <h1 className="gradient-text" style={{ fontSize: '2.2rem', fontWeight: 800, marginBottom: 24 }}>{msg}</h1>
            <Card style={{ textAlign: 'center', minWidth: 280 }}>
                <div style={{ fontSize: '3.5rem', fontWeight: 800, color: 'var(--yellow)' }}>{score}</div>
                {maxScore && <div style={{ color: 'var(--text-secondary)' }}>/ {maxScore} points</div>}
                {level && <div style={{ color: 'var(--text-muted)', marginTop: 8 }}>Niveau atteint : {level}</div>}
                {stats && (
                    <div style={{ display: 'flex', justifyContent: 'center', gap: 20, marginTop: 16, paddingTop: 16, borderTop: '1px solid rgba(255,255,255,0.1)' }}>
                        {Object.entries(stats).map(([k, v]) => <Stat key={k} label={k} value={v} color="var(--cyan)" />)}
                    </div>
                )}
            </Card>
            <div style={{ display: 'flex', gap: 16, marginTop: 24 }}>
                <button className="btn btn-primary" onClick={onRetry}>Rejouer</button>
                <button className="btn btn-secondary" onClick={onBack}>Retour</button>
            </div>
        </div>
    );
};

const CountdownOverlay = ({ count, onComplete }) => {
    const [c, setC] = useState(count);
    useEffect(() => {
        if (c > 0) { const t = setTimeout(() => setC(x => x - 1), 1000); return () => clearTimeout(t); }
        else onComplete();
    }, [c, onComplete]);
    if (c === 0) return null;
    return (
        <div style={{ position: 'fixed', inset: 0, background: 'rgba(5,5,10,0.95)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 1000 }}>
            <div className="scaleIn" key={c} style={{ fontSize: '8rem', fontWeight: 900, color: 'var(--cyan)', textShadow: '0 0 60px var(--cyan)' }}>{c}</div>
        </div>
    );
};

// ===== GAME: SEQUENCE =====
const SequenceGame = ({ onBack }) => {
    const [phase, setPhase] = useState('ready');
    const [sequence, setSequence] = useState([]);
    const [userSeq, setUserSeq] = useState([]);
    const [level, setLevel] = useState(1);
    const [showIdx, setShowIdx] = useState(-1);
    const [score, setScore] = useState(0);
    const [lives, setLives] = useState(3);
    const [feedback, setFeedback] = useState(null);

    const startLevel = useCallback(async () => {
        const seq = Array.from({ length: level + 2 }, () => pick(COLORS));
        setSequence(seq); setUserSeq([]); setPhase('showing');
        for (let i = 0; i < seq.length; i++) { await sleep(300); setShowIdx(i); await sleep(500); setShowIdx(-1); }
        await sleep(200); setPhase('input');
    }, [level]);

    useEffect(() => { if (phase === 'ready') { const t = setTimeout(startLevel, 800); return () => clearTimeout(t); } }, [phase, startLevel]);

    const handleClick = (color) => {
        if (phase !== 'input') return;
        const newSeq = [...userSeq, color]; setUserSeq(newSeq);
        if (newSeq[newSeq.length - 1] !== sequence[newSeq.length - 1]) {
            setFeedback('error'); setLives(l => l - 1);
            if (lives <= 1) setTimeout(() => setPhase('result'), 500);
            else setTimeout(() => { setFeedback(null); setPhase('ready'); }, 1000);
            return;
        }
        if (newSeq.length === sequence.length) {
            setFeedback('success'); setScore(s => s + level * 15);
            setTimeout(() => { setFeedback(null); setLevel(l => l + 1); setPhase('ready'); }, 1000);
        }
    };

    if (phase === 'result') return <ResultScreen score={score} level={level} onRetry={() => { setLevel(1); setScore(0); setLives(3); setPhase('ready'); }} onBack={onBack} />;

    return (
        <div style={{ minHeight: '100vh', display: 'flex', flexDirection: 'column' }}>
            <Header title="S√©quence Visuelle" onBack={onBack} lives={lives} score={score} level={level} />
            <div style={{ flex: 1, display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', padding: 20 }}>
                <p style={{ color: 'var(--text-secondary)', marginBottom: 24, fontFamily: 'var(--font-mono)' }}>
                    {phase === 'showing' && `M√©morise ! (${showIdx + 1}/${sequence.length})`}
                    {phase === 'input' && `√Ä toi ! (${userSeq.length}/${sequence.length})`}
                    {phase === 'ready' && 'Pr√©pare-toi...'}
                </p>
                <div className={feedback === 'error' ? 'shake' : ''} style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: 12 }}>
                    {COLORS.map(c => (
                        <button key={c} onClick={() => handleClick(c)} disabled={phase !== 'input'} style={{
                            width: 80, height: 80, borderRadius: 'var(--radius-md)', border: 'none', background: COLOR_HEX[c],
                            cursor: phase === 'input' ? 'pointer' : 'default',
                            opacity: phase === 'showing' && showIdx >= 0 && sequence[showIdx] !== c ? 0.3 : 1,
                            transform: sequence[showIdx] === c ? 'scale(1.15)' : 'scale(1)',
                            boxShadow: sequence[showIdx] === c ? `0 0 30px ${COLOR_HEX[c]}` : 'none',
                            transition: 'all 0.15s ease'
                        }} />
                    ))}
                </div>
                {feedback && <Feedback type={feedback} message={feedback === 'success' ? 'Parfait !' : 'Rat√© !'} />}
            </div>
        </div>
    );
};

// ===== GAME: N-BACK =====
const NBackGame = ({ onBack }) => {
    const [phase, setPhase] = useState('intro');
    const [n, setN] = useState(1);
    const [sequence, setSequence] = useState([]);
    const [idx, setIdx] = useState(0);
    const [score, setScore] = useState(0);
    const [lives, setLives] = useState(3);
    const [feedback, setFeedback] = useState(null);
    const [stats, setStats] = useState({ correct: 0, total: 0 });
    const seqLen = 15;

    const genSeq = useCallback(() => {
        const seq = [];
        for (let i = 0; i < seqLen; i++) {
            if (i >= n && Math.random() < 0.3) seq.push(seq[i - n]);
            else seq.push(pick(COLORS));
        }
        return seq;
    }, [n]);

    const start = () => { setSequence(genSeq()); setIdx(0); setPhase('playing'); setFeedback(null); };

    useEffect(() => {
        if (phase === 'playing' && idx < seqLen) {
            const t = setTimeout(() => {
                if (idx >= n && sequence[idx] !== sequence[idx - n]) setIdx(i => i + 1);
                else if (idx < n) setIdx(i => i + 1);
            }, 2500);
            return () => clearTimeout(t);
        } else if (phase === 'playing' && idx >= seqLen) setPhase('result');
    }, [phase, idx, sequence, n, seqLen]);

    const handleResponse = (isMatch) => {
        const actual = sequence[idx] === sequence[idx - n];
        const correct = isMatch === actual;
        setStats(s => ({ correct: s.correct + (correct ? 1 : 0), total: s.total + 1 }));
        if (correct) { setScore(s => s + 10 * n); setFeedback('success'); }
        else { setLives(l => l - 1); setFeedback('error'); if (lives <= 1) { setTimeout(() => setPhase('result'), 500); return; } }
        setTimeout(() => { setFeedback(null); setIdx(i => i + 1); }, 500);
    };

    if (phase === 'result') return <ResultScreen score={score} level={n} stats={{ Pr√©cision: `${stats.total > 0 ? Math.round((stats.correct / stats.total) * 100) : 0}%` }} onRetry={() => { setScore(0); setLives(3); setStats({ correct: 0, total: 0 }); setPhase('intro'); }} onBack={onBack} />;

    if (phase === 'intro') return (
        <div style={{ minHeight: '100vh', display: 'flex', flexDirection: 'column' }}>
            <Header title="N-Back Adaptatif" onBack={onBack} />
            <div style={{ flex: 1, display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', padding: 20 }}>
                <Card style={{ textAlign: 'center', maxWidth: 400 }}>
                    <div style={{ fontSize: '3rem', marginBottom: 16 }}>üîÑ</div>
                    <h2 style={{ marginBottom: 12 }}>N = {n}</h2>
                    <p style={{ color: 'var(--text-secondary)', marginBottom: 20, lineHeight: 1.6 }}>
                        Appuie sur <strong style={{ color: 'var(--cyan)' }}>MATCH</strong> si la couleur est identique √† celle d'il y a <strong style={{ color: 'var(--yellow)' }}>{n} √©tape{n > 1 ? 's' : ''}</strong>.
                    </p>
                    <div style={{ display: 'flex', gap: 10, justifyContent: 'center', marginBottom: 20 }}>
                        {[1, 2, 3].map(l => <button key={l} onClick={() => setN(l)} className={`btn ${n === l ? 'btn-primary' : 'btn-secondary'}`} style={{ padding: '10px 20px' }}>N={l}</button>)}
                    </div>
                </Card>
                <button className="btn btn-primary" onClick={start} style={{ marginTop: 24 }}>Commencer</button>
            </div>
        </div>
    );

    return (
        <div style={{ minHeight: '100vh', display: 'flex', flexDirection: 'column' }}>
            <Header title={`N-Back (N=${n})`} onBack={onBack} lives={lives} score={score} progress={(idx / seqLen) * 100} />
            <div style={{ flex: 1, display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', padding: 20 }}>
                <p style={{ color: 'var(--text-muted)', marginBottom: 16, fontFamily: 'var(--font-mono)' }}>{idx + 1} / {seqLen}</p>
                <div className={feedback === 'error' ? 'shake' : feedback === 'success' ? 'pulse' : ''} style={{
                    width: 140, height: 140, borderRadius: 'var(--radius-lg)', background: COLOR_HEX[sequence[idx]],
                    boxShadow: `0 0 50px ${COLOR_HEX[sequence[idx]]}66`, marginBottom: 32, transition: 'all 0.3s ease'
                }} />
                {idx >= n ? (
                    <div style={{ display: 'flex', gap: 16 }}>
                        <button className="btn btn-secondary" onClick={() => handleResponse(false)} style={{ minWidth: 110 }}>Diff√©rent</button>
                        <button className="btn btn-primary" onClick={() => handleResponse(true)} style={{ minWidth: 110 }}>MATCH !</button>
                    </div>
                ) : <p style={{ color: 'var(--text-muted)' }}>M√©morise... ({n - idx} de plus)</p>}
            </div>
        </div>
    );
};

// ===== GAME: CHUNKING =====
const ChunkingGame = ({ onBack }) => {
    const [phase, setPhase] = useState('memorize');
    const [numbers, setNumbers] = useState([]);
    const [chunks, setChunks] = useState([]);
    const [options, setOptions] = useState([]);
    const [level, setLevel] = useState(1);
    const [score, setScore] = useState(0);
    const [lives, setLives] = useState(3);
    const [timer, setTimer] = useState(0);
    const [feedback, setFeedback] = useState(null);

    const genLevel = useCallback(() => {
        const len = 4 + level * 2;
        const nums = Array.from({ length: len }, () => Math.floor(Math.random() * 10));
        const chunkSize = 2 + Math.floor(level / 2);
        const chunked = [];
        for (let i = 0; i < nums.length; i += chunkSize) chunked.push(nums.slice(i, i + chunkSize).join(''));
        setNumbers(nums); setChunks(chunked); setTimer(3 + level); setPhase('memorize');
    }, [level]);

    useEffect(() => { genLevel(); }, []);

    useEffect(() => {
        if (phase === 'memorize' && timer > 0) { const t = setTimeout(() => setTimer(x => x - 1), 1000); return () => clearTimeout(t); }
        else if (phase === 'memorize' && timer === 0) {
            const correct = numbers.join('');
            const wrongs = [numbers.slice().reverse().join(''), numbers.map(n => (n + 1) % 10).join(''), shuffle(numbers).join('')].filter(w => w !== correct);
            setOptions(shuffle([correct, ...wrongs.slice(0, 3)])); setPhase('recall');
        }
    }, [phase, timer, numbers]);

    const handleAnswer = (ans) => {
        const correct = numbers.join('');
        if (ans === correct) {
            setFeedback('success'); setScore(s => s + level * 20);
            setTimeout(() => { setFeedback(null); setLevel(l => l + 1); genLevel(); }, 1000);
        } else {
            setFeedback('error'); setLives(l => l - 1);
            if (lives <= 1) setTimeout(() => setPhase('result'), 500);
            else setTimeout(() => { setFeedback(null); genLevel(); }, 1000);
        }
    };

    if (phase === 'result') return <ResultScreen score={score} level={level} onRetry={() => { setLevel(1); setScore(0); setLives(3); genLevel(); }} onBack={onBack} />;

    return (
        <div style={{ minHeight: '100vh', display: 'flex', flexDirection: 'column' }}>
            <Header title="Chunking Master" onBack={onBack} lives={lives} score={score} level={level} timer={phase === 'memorize' ? timer : undefined} />
            <div style={{ flex: 1, display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', padding: 20 }}>
                {phase === 'memorize' && (
                    <>
                        <p style={{ color: 'var(--text-secondary)', marginBottom: 16 }}>M√©morise cette s√©quence :</p>
                        <div style={{ display: 'flex', gap: 8, marginBottom: 16 }}>
                            {chunks.map((ch, i) => <div key={i} className="glass" style={{ padding: '14px 18px', borderRadius: 'var(--radius-md)' }}><span style={{ fontFamily: 'var(--font-mono)', fontSize: '1.4rem', fontWeight: 700, color: 'var(--cyan)' }}>{ch}</span></div>)}
                        </div>
                        <p style={{ color: 'var(--text-muted)', fontSize: '0.85rem' }}>üí° Regroupe en chunks pour mieux m√©moriser</p>
                    </>
                )}
                {phase === 'recall' && (
                    <>
                        <p style={{ color: 'var(--text-secondary)', marginBottom: 16 }}>Quelle √©tait la s√©quence ?</p>
                        <div style={{ display: 'flex', flexDirection: 'column', gap: 10, width: '100%', maxWidth: 360 }}>
                            {options.map((opt, i) => <OptionBtn key={i} onClick={() => handleAnswer(opt)} disabled={!!feedback} correct={feedback && opt === numbers.join('')} wrong={feedback === 'error' && opt !== numbers.join('')}><span style={{ fontFamily: 'var(--font-mono)', letterSpacing: 2 }}>{opt}</span></OptionBtn>)}
                        </div>
                    </>
                )}
                {feedback && <Feedback type={feedback} message={feedback === 'success' ? 'Exact !' : 'Incorrect !'} />}
            </div>
        </div>
    );
};

// ===== GAME: UPDATING (Liste Vivante) =====
const UpdatingGame = ({ onBack }) => {
    const [phase, setPhase] = useState('playing');
    const [initList, setInitList] = useState([]);
    const [finalList, setFinalList] = useState([]);
    const [instruction, setInstruction] = useState('');
    const [options, setOptions] = useState([]);
    const [level, setLevel] = useState(1);
    const [round, setRound] = useState(0);
    const [score, setScore] = useState(0);
    const [lives, setLives] = useState(3);
    const [feedback, setFeedback] = useState(null);
    const [showInstr, setShowInstr] = useState(true);
    const maxRounds = 5;

    const genRound = useCallback(() => {
        const size = 3 + Math.floor(level / 2);
        const init = Array.from({ length: size }, () => pick(COLORS));
        let current = [...init];
        const ops = [];
        const numOps = 1 + Math.floor(level / 2);
        
        for (let i = 0; i < numOps; i++) {
            const opType = pick(['add', 'remove', 'swap', 'reverse'].filter(t => {
                if (t === 'remove' && current.length <= 2) return false;
                if (t === 'swap' && current.length <= 1) return false;
                return true;
            }));
            
            if (opType === 'add') {
                const c = pick(COLORS); ops.push(`Ajoute ${c}`); current.push(c);
            } else if (opType === 'remove') {
                const p = Math.floor(Math.random() * current.length) + 1; ops.push(`Supprime le ${p}√®me`); current.splice(p - 1, 1);
            } else if (opType === 'swap') {
                const p1 = Math.floor(Math.random() * current.length) + 1;
                let p2 = Math.floor(Math.random() * current.length) + 1;
                while (p2 === p1) p2 = Math.floor(Math.random() * current.length) + 1;
                ops.push(`√âchange ${p1} et ${p2}`);
                [current[p1-1], current[p2-1]] = [current[p2-1], current[p1-1]];
            } else {
                ops.push(`Inverse l'ordre`); current.reverse();
            }
        }
        
        setInitList(init); setFinalList(current); setInstruction(ops.join(' ‚Üí '));
        const correct = current.join('-');
        const wrongs = [shuffle([...current]).join('-'), [...current].reverse().join('-'), current.map(() => pick(COLORS)).join('-')].filter(w => w !== correct);
        setOptions(shuffle([correct, ...wrongs.slice(0, 3)]));
        setShowInstr(true);
    }, [level]);

    useEffect(() => { genRound(); }, []);
    useEffect(() => { if (showInstr) { const t = setTimeout(() => setShowInstr(false), 3000 + level * 500); return () => clearTimeout(t); } }, [showInstr, level]);

    const handleAnswer = (ans) => {
        const correct = finalList.join('-');
        if (ans === correct) {
            setFeedback('success'); setScore(s => s + level * 25);
            setTimeout(() => { setFeedback(null); if (round + 1 >= maxRounds) { setLevel(l => l + 1); setRound(0); } else setRound(r => r + 1); genRound(); }, 1000);
        } else {
            setFeedback('error'); setLives(l => l - 1);
            if (lives <= 1) setTimeout(() => setPhase('result'), 500);
            else setTimeout(() => { setFeedback(null); genRound(); }, 1500);
        }
    };

    if (phase === 'result') return <ResultScreen score={score} level={level} onRetry={() => { setLevel(1); setRound(0); setScore(0); setLives(3); genRound(); setPhase('playing'); }} onBack={onBack} />;

    return (
        <div style={{ minHeight: '100vh', display: 'flex', flexDirection: 'column' }}>
            <Header title="Liste Vivante" onBack={onBack} lives={lives} score={score} level={level} progress={(round / maxRounds) * 100} />
            <div style={{ flex: 1, display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', padding: 20 }}>
                {showInstr ? (
                    <>
                        <p style={{ color: 'var(--text-secondary)', marginBottom: 12 }}>Liste initiale :</p>
                        <div style={{ display: 'flex', gap: 8, marginBottom: 20 }}>
                            {initList.map((c, i) => <div key={i} style={{ width: 45, height: 45, borderRadius: 10, background: COLOR_HEX[c], display: 'flex', alignItems: 'center', justifyContent: 'center', fontWeight: 700, color: '#000' }}>{i + 1}</div>)}
                        </div>
                        <Card><p style={{ color: 'var(--yellow)', fontWeight: 600, textAlign: 'center' }}>üìù {instruction}</p></Card>
                        <p style={{ color: 'var(--text-muted)', marginTop: 16, fontSize: '0.85rem' }}>M√©morise les transformations...</p>
                    </>
                ) : (
                    <>
                        <p style={{ color: 'var(--text-secondary)', marginBottom: 16 }}>Quel est le r√©sultat final ?</p>
                        <div style={{ display: 'flex', flexDirection: 'column', gap: 10, width: '100%', maxWidth: 360 }}>
                            {options.map((opt, i) => (
                                <OptionBtn key={i} onClick={() => handleAnswer(opt)} disabled={!!feedback} correct={feedback && opt === finalList.join('-')} wrong={feedback === 'error' && opt !== finalList.join('-')}>
                                    <div style={{ display: 'flex', gap: 6 }}>{opt.split('-').map((c, j) => <div key={j} style={{ width: 32, height: 32, borderRadius: 6, background: COLOR_HEX[c] }} />)}</div>
                                </OptionBtn>
                            ))}
                        </div>
                    </>
                )}
                {feedback && <Feedback type={feedback} message={feedback === 'success' ? 'Correct !' : 'Incorrect !'} />}
            </div>
        </div>
    );
};

// ===== GAME: HALLUCINATION =====
const HallucinationGame = ({ onBack }) => {
    const [phase, setPhase] = useState('playing');
    const [current, setCurrent] = useState(null);
    const [round, setRound] = useState(0);
    const [score, setScore] = useState(0);
    const [lives, setLives] = useState(3);
    const [feedback, setFeedback] = useState(null);
    const [used, setUsed] = useState([]);
    const maxRounds = 8;

    const next = useCallback(() => {
        const avail = HALLUCINATION_DATA.map((_, i) => i).filter(i => !used.includes(i));
        if (avail.length === 0) { setUsed([]); setCurrent(HALLUCINATION_DATA[0]); return; }
        const idx = pick(avail); setUsed(p => [...p, idx]); setCurrent(HALLUCINATION_DATA[idx]); setFeedback(null);
    }, [used]);

    useEffect(() => { next(); }, []);

    const handleAnswer = (hasErr) => {
        const correct = hasErr === current.hasError;
        if (correct) {
            setFeedback('success'); setScore(s => s + 30);
            setTimeout(() => { if (round + 1 >= maxRounds) setPhase('result'); else { setRound(r => r + 1); next(); } }, 1500);
        } else {
            setFeedback('error'); setLives(l => l - 1);
            if (lives <= 1) setTimeout(() => setPhase('result'), 1000);
            else setTimeout(() => { setRound(r => r + 1); next(); }, 2000);
        }
    };

    if (phase === 'result') return <ResultScreen score={score} maxScore={maxRounds * 30} stats={{ D√©tect√©es: `${round}/${maxRounds}` }} onRetry={() => { setRound(0); setScore(0); setLives(3); setUsed([]); next(); setPhase('playing'); }} onBack={onBack} />;

    return (
        <div style={{ minHeight: '100vh', display: 'flex', flexDirection: 'column' }}>
            <Header title="Spot the Hallucination" subtitle="D√©tecte les erreurs de l'IA" onBack={onBack} lives={lives} score={score} progress={(round / maxRounds) * 100} />
            <div style={{ flex: 1, display: 'flex', flexDirection: 'column', padding: 20 }}>
                {current && (
                    <Card>
                        <p style={{ fontSize: '1.05rem', lineHeight: 1.7 }}>{current.text}</p>
                        {feedback === 'error' && current.hasError && <div style={{ marginTop: 12, padding: 10, background: 'rgba(239,68,68,0.1)', borderRadius: 8, borderLeft: '3px solid var(--red)' }}><p style={{ color: 'var(--red)', fontSize: '0.9rem' }}>‚ùå {current.error}</p></div>}
                        {feedback === 'success' && !current.hasError && <div style={{ marginTop: 12, padding: 10, background: 'rgba(34,197,94,0.1)', borderRadius: 8, borderLeft: '3px solid var(--green)' }}><p style={{ color: 'var(--green)', fontSize: '0.9rem' }}>‚úì Pas d'erreur factuelle</p></div>}
                    </Card>
                )}
                <div style={{ marginTop: 'auto', padding: '20px 0' }}>
                    <p style={{ textAlign: 'center', color: 'var(--text-secondary)', marginBottom: 12 }}>Ce texte contient-il une erreur ?</p>
                    <div style={{ display: 'flex', gap: 12, justifyContent: 'center' }}>
                        <button className="btn btn-secondary" onClick={() => handleAnswer(false)} disabled={!!feedback} style={{ minWidth: 130, background: 'rgba(34,197,94,0.1)', borderColor: 'var(--green)', color: 'var(--green)' }}>‚úì Correct</button>
                        <button className="btn btn-secondary" onClick={() => handleAnswer(true)} disabled={!!feedback} style={{ minWidth: 130, background: 'rgba(239,68,68,0.1)', borderColor: 'var(--red)', color: 'var(--red)' }}>‚úó Erreur</button>
                    </div>
                </div>
            </div>
        </div>
    );
};

// ===== GAME: FALLACY =====
const FallacyGame = ({ onBack }) => {
    const [phase, setPhase] = useState('playing');
    const [current, setCurrent] = useState(null);
    const [round, setRound] = useState(0);
    const [score, setScore] = useState(0);
    const [lives, setLives] = useState(3);
    const [feedback, setFeedback] = useState(null);
    const [selected, setSelected] = useState(null);
    const maxRounds = 6;

    const next = useCallback(() => { setCurrent(FALLACY_DATA[round % FALLACY_DATA.length]); setSelected(null); setFeedback(null); }, [round]);
    useEffect(() => { next(); }, []);

    const handleAnswer = (ans) => {
        setSelected(ans);
        const correct = ans === current.fallacy;
        if (correct) {
            setFeedback('success'); setScore(s => s + 35);
            setTimeout(() => { if (round + 1 >= maxRounds) setPhase('result'); else { setRound(r => r + 1); next(); } }, 1200);
        } else {
            setFeedback('error'); setLives(l => l - 1);
            if (lives <= 1) setTimeout(() => setPhase('result'), 1000);
            else setTimeout(() => { setRound(r => r + 1); next(); }, 1500);
        }
    };

    if (phase === 'result') return <ResultScreen score={score} maxScore={maxRounds * 35} stats={{ Identifi√©s: `${round}/${maxRounds}` }} onRetry={() => { setRound(0); setScore(0); setLives(3); next(); setPhase('playing'); }} onBack={onBack} />;

    return (
        <div style={{ minHeight: '100vh', display: 'flex', flexDirection: 'column' }}>
            <Header title="Bullshit Detector" subtitle="Identifie le sophisme" onBack={onBack} lives={lives} score={score} progress={(round / maxRounds) * 100} />
            <div style={{ flex: 1, display: 'flex', flexDirection: 'column', padding: 20 }}>
                {current && (
                    <>
                        <Card><p style={{ fontSize: '1.1rem', lineHeight: 1.7, fontStyle: 'italic' }}>"{current.text}"</p></Card>
                        <p style={{ textAlign: 'center', color: 'var(--text-secondary)', margin: '20px 0 12px' }}>Quel sophisme est utilis√© ?</p>
                        <div style={{ display: 'flex', flexDirection: 'column', gap: 10, padding: '0 20px' }}>
                            {current.options.map((opt, i) => (
                                <OptionBtn key={i} onClick={() => handleAnswer(opt)} disabled={!!feedback} correct={feedback && opt === current.fallacy} wrong={feedback === 'error' && selected === opt && opt !== current.fallacy}>{opt}</OptionBtn>
                            ))}
                        </div>
                    </>
                )}
                {feedback && <Feedback type={feedback} message={feedback === 'success' ? 'Exact !' : `C'√©tait : ${current.fallacy}`} />}
            </div>
        </div>
    );
};

// ===== GAME: TRILEMMA =====
const TrilemmaGame = ({ onBack }) => {
    const [phase, setPhase] = useState('playing');
    const [current, setCurrent] = useState(null);
    const [round, setRound] = useState(0);
    const [score, setScore] = useState(0);
    const [lives, setLives] = useState(3);
    const [feedback, setFeedback] = useState(null);
    const maxRounds = 8;

    const next = useCallback(() => { setCurrent(TRILEMMA_DATA[round % TRILEMMA_DATA.length]); setFeedback(null); }, [round]);
    useEffect(() => { next(); }, []);

    const handleAnswer = (ans) => {
        const correct = ans === current.answer;
        if (correct) {
            setFeedback('success'); setScore(s => s + 25);
            setTimeout(() => { if (round + 1 >= maxRounds) setPhase('result'); else { setRound(r => r + 1); next(); } }, 1200);
        } else {
            setFeedback('error'); setLives(l => l - 1);
            if (lives <= 1) setTimeout(() => setPhase('result'), 1000);
            else setTimeout(() => { setRound(r => r + 1); next(); }, 1500);
        }
    };

    if (phase === 'result') return <ResultScreen score={score} maxScore={maxRounds * 25} onRetry={() => { setRound(0); setScore(0); setLives(3); next(); setPhase('playing'); }} onBack={onBack} />;

    const answers = [
        { id: 'true', label: 'VRAI', color: 'var(--green)', icon: '‚úì' },
        { id: 'false', label: 'FAUX', color: 'var(--red)', icon: '‚úó' },
        { id: 'unknown', label: 'INV√âRIFIABLE', color: 'var(--yellow)', icon: '?' }
    ];

    return (
        <div style={{ minHeight: '100vh', display: 'flex', flexDirection: 'column' }}>
            <Header title="Vrai / Faux / ?" subtitle="Distingue le v√©rifiable" onBack={onBack} lives={lives} score={score} progress={(round / maxRounds) * 100} />
            <div style={{ flex: 1, display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', padding: 20 }}>
                {current && (
                    <>
                        <Card style={{ textAlign: 'center', maxWidth: 500 }}>
                            <p style={{ fontSize: '1.2rem', lineHeight: 1.6 }}>{current.statement}</p>
                        </Card>
                        <div style={{ display: 'flex', gap: 12, marginTop: 24, flexWrap: 'wrap', justifyContent: 'center' }}>
                            {answers.map(a => (
                                <button key={a.id} className="btn btn-secondary" onClick={() => handleAnswer(a.id)} disabled={!!feedback} style={{ minWidth: 120, background: `${a.color}15`, borderColor: feedback && current.answer === a.id ? a.color : 'transparent', color: a.color }}>
                                    <span style={{ fontSize: '1.2rem', marginRight: 6 }}>{a.icon}</span>{a.label}
                                </button>
                            ))}
                        </div>
                    </>
                )}
                {feedback && <Feedback type={feedback} message={feedback === 'success' ? 'Correct !' : `R√©ponse : ${answers.find(a => a.id === current.answer)?.label}`} />}
            </div>
        </div>
    );
};

// ===== GAME: HUMAN vs AI =====
const HumanAIGame = ({ onBack }) => {
    const [phase, setPhase] = useState('playing');
    const [current, setCurrent] = useState(null);
    const [round, setRound] = useState(0);
    const [score, setScore] = useState(0);
    const [lives, setLives] = useState(3);
    const [feedback, setFeedback] = useState(null);
    const maxRounds = 6;

    const next = useCallback(() => { setCurrent(HUMAN_AI_DATA[round % HUMAN_AI_DATA.length]); setFeedback(null); }, [round]);
    useEffect(() => { next(); }, []);

    const handleAnswer = (ans) => {
        const correct = ans === current.author;
        if (correct) {
            setFeedback('success'); setScore(s => s + 30);
            setTimeout(() => { if (round + 1 >= maxRounds) setPhase('result'); else { setRound(r => r + 1); next(); } }, 1200);
        } else {
            setFeedback('error'); setLives(l => l - 1);
            if (lives <= 1) setTimeout(() => setPhase('result'), 1000);
            else setTimeout(() => { setRound(r => r + 1); next(); }, 1500);
        }
    };

    if (phase === 'result') return <ResultScreen score={score} maxScore={maxRounds * 30} onRetry={() => { setRound(0); setScore(0); setLives(3); next(); setPhase('playing'); }} onBack={onBack} />;

    return (
        <div style={{ minHeight: '100vh', display: 'flex', flexDirection: 'column' }}>
            <Header title="Humain ou IA ?" subtitle="Identifie l'origine" onBack={onBack} lives={lives} score={score} progress={(round / maxRounds) * 100} />
            <div style={{ flex: 1, display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', padding: 20 }}>
                {current && (
                    <>
                        <Card style={{ maxWidth: 500 }}>
                            <p style={{ fontSize: '1.1rem', lineHeight: 1.7, fontStyle: 'italic' }}>"{current.text}"</p>
                        </Card>
                        <div style={{ display: 'flex', gap: 16, marginTop: 24 }}>
                            <button className="btn btn-secondary" onClick={() => handleAnswer('human')} disabled={!!feedback} style={{ minWidth: 130, background: feedback && current.author === 'human' ? 'rgba(34,197,94,0.2)' : 'var(--bg-elevated)', borderColor: feedback && current.author === 'human' ? 'var(--green)' : 'transparent' }}>
                                üë§ Humain
                            </button>
                            <button className="btn btn-secondary" onClick={() => handleAnswer('ai')} disabled={!!feedback} style={{ minWidth: 130, background: feedback && current.author === 'ai' ? 'rgba(34,197,94,0.2)' : 'var(--bg-elevated)', borderColor: feedback && current.author === 'ai' ? 'var(--green)' : 'transparent' }}>
                                ü§ñ IA
                            </button>
                        </div>
                    </>
                )}
                {feedback && <Feedback type={feedback} message={feedback === 'success' ? 'Bien vu !' : `C'√©tait ${current.author === 'human' ? 'un humain' : 'une IA'}`} />}
            </div>
        </div>
    );
};

// ===== GAME: CAUSAL CHAIN =====
const CausalGame = ({ onBack }) => {
    const [phase, setPhase] = useState('playing');
    const [current, setCurrent] = useState(null);
    const [shuffled, setShuffled] = useState([]);
    const [selected, setSelected] = useState([]);
    const [round, setRound] = useState(0);
    const [score, setScore] = useState(0);
    const [lives, setLives] = useState(3);
    const [feedback, setFeedback] = useState(null);
    const maxRounds = 3;

    const next = useCallback(() => {
        const data = CAUSAL_DATA[round % CAUSAL_DATA.length];
        setCurrent(data); setShuffled(shuffle([...data.steps])); setSelected([]); setFeedback(null);
    }, [round]);

    useEffect(() => { next(); }, []);

    const handleSelect = (step) => {
        if (selected.includes(step)) return;
        const newSel = [...selected, step]; setSelected(newSel);
        if (newSel.length === current.steps.length) {
            const correct = newSel.every((s, i) => s === current.steps[i]);
            if (correct) {
                setFeedback('success'); setScore(s => s + 50);
                setTimeout(() => { if (round + 1 >= maxRounds) setPhase('result'); else { setRound(r => r + 1); next(); } }, 1500);
            } else {
                setFeedback('error'); setLives(l => l - 1);
                if (lives <= 1) setTimeout(() => setPhase('result'), 1000);
                else setTimeout(() => { next(); }, 2000);
            }
        }
    };

    const handleReset = () => setSelected([]);

    if (phase === 'result') return <ResultScreen score={score} maxScore={maxRounds * 50} onRetry={() => { setRound(0); setScore(0); setLives(3); next(); setPhase('playing'); }} onBack={onBack} />;

    return (
        <div style={{ minHeight: '100vh', display: 'flex', flexDirection: 'column' }}>
            <Header title="Cha√Æne Causale" subtitle={current?.event} onBack={onBack} lives={lives} score={score} progress={(round / maxRounds) * 100} />
            <div style={{ flex: 1, display: 'flex', flexDirection: 'column', padding: 20 }}>
                <p style={{ textAlign: 'center', color: 'var(--text-secondary)', marginBottom: 16 }}>Remets les √©tapes dans l'ordre causal :</p>
                
                {selected.length > 0 && (
                    <div style={{ display: 'flex', flexWrap: 'wrap', gap: 8, marginBottom: 16, padding: 12, background: 'var(--bg-card)', borderRadius: 'var(--radius-md)' }}>
                        {selected.map((s, i) => (
                            <div key={i} style={{ display: 'flex', alignItems: 'center', gap: 4 }}>
                                <span className="glass" style={{ padding: '8px 12px', borderRadius: 8, fontSize: '0.9rem' }}>{i + 1}. {s}</span>
                                {i < selected.length - 1 && <span style={{ color: 'var(--cyan)' }}>‚Üí</span>}
                            </div>
                        ))}
                    </div>
                )}
                
                <div style={{ display: 'flex', flexDirection: 'column', gap: 8 }}>
                    {shuffled.filter(s => !selected.includes(s)).map((step, i) => (
                        <OptionBtn key={i} onClick={() => handleSelect(step)} disabled={!!feedback}>{step}</OptionBtn>
                    ))}
                </div>
                
                {selected.length > 0 && !feedback && (
                    <button className="btn btn-ghost" onClick={handleReset} style={{ marginTop: 12, alignSelf: 'center' }}>‚Ü∫ Recommencer</button>
                )}
                
                {feedback && <Feedback type={feedback} message={feedback === 'success' ? 'Cha√Æne correcte !' : 'Ordre incorrect'} />}
            </div>
        </div>
    );
};

// ===== GAME: RECALL =====
const RecallGame = ({ onBack }) => {
    const [phase, setPhase] = useState('memorize');
    const [words, setWords] = useState([]);
    const [options, setOptions] = useState([]);
    const [selected, setSelected] = useState([]);
    const [level, setLevel] = useState(1);
    const [score, setScore] = useState(0);
    const [lives, setLives] = useState(3);
    const [timer, setTimer] = useState(0);
    const [feedback, setFeedback] = useState(null);

    const WORD_POOL = ['soleil', 'montagne', 'oc√©an', 'for√™t', '√©toile', 'cerveau', 'm√©moire', 'neurone', 'bitcoin', 'crypto', 'wallet', 'nuage', 'rivi√®re', 'ch√¢teau', 'dragon'];

    const genLevel = useCallback(() => {
        const count = 3 + level;
        const w = pickN(WORD_POOL, count);
        const distractors = pickN(WORD_POOL.filter(x => !w.includes(x)), 3);
        setWords(w); setOptions(shuffle([...w, ...distractors])); setSelected([]); setTimer(3 + level); setPhase('memorize');
    }, [level]);

    useEffect(() => { genLevel(); }, []);

    useEffect(() => {
        if (phase === 'memorize' && timer > 0) { const t = setTimeout(() => setTimer(x => x - 1), 1000); return () => clearTimeout(t); }
        else if (phase === 'memorize' && timer === 0) { setTimer(5); setPhase('distraction'); }
        else if (phase === 'distraction' && timer > 0) { const t = setTimeout(() => setTimer(x => x - 1), 1000); return () => clearTimeout(t); }
        else if (phase === 'distraction' && timer === 0) setPhase('recall');
    }, [phase, timer]);

    const toggleWord = (w) => {
        if (selected.includes(w)) setSelected(selected.filter(x => x !== w));
        else setSelected([...selected, w]);
    };

    const handleSubmit = () => {
        const correctCount = selected.filter(w => words.includes(w)).length;
        const wrongCount = selected.filter(w => !words.includes(w)).length;
        const pts = (correctCount * 20) - (wrongCount * 10);
        
        if (correctCount === words.length && wrongCount === 0) {
            setFeedback('success'); setScore(s => s + pts + level * 10);
            setTimeout(() => { setFeedback(null); setLevel(l => l + 1); genLevel(); }, 1500);
        } else if (correctCount >= words.length / 2) {
            setFeedback('info'); setScore(s => s + Math.max(0, pts));
            setTimeout(() => { setFeedback(null); genLevel(); }, 1500);
        } else {
            setFeedback('error'); setLives(l => l - 1);
            if (lives <= 1) setTimeout(() => setPhase('result'), 1000);
            else setTimeout(() => { setFeedback(null); genLevel(); }, 1500);
        }
    };

    if (phase === 'result') return <ResultScreen score={score} level={level} onRetry={() => { setLevel(1); setScore(0); setLives(3); genLevel(); }} onBack={onBack} />;

    return (
        <div style={{ minHeight: '100vh', display: 'flex', flexDirection: 'column' }}>
            <Header title="Rappel Diff√©r√©" onBack={onBack} lives={lives} score={score} level={level} timer={phase !== 'recall' ? timer : undefined} />
            <div style={{ flex: 1, display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', padding: 20 }}>
                {phase === 'memorize' && (
                    <>
                        <p style={{ color: 'var(--text-secondary)', marginBottom: 16 }}>M√©morise ces {words.length} mots :</p>
                        <div style={{ display: 'flex', flexWrap: 'wrap', gap: 10, justifyContent: 'center' }}>
                            {words.map((w, i) => <span key={i} className="glass fadeIn" style={{ padding: '10px 16px', borderRadius: 10, color: 'var(--cyan)', fontWeight: 600, animationDelay: `${i * 0.1}s` }}>{w}</span>)}
                        </div>
                    </>
                )}
                {phase === 'distraction' && (
                    <>
                        <p style={{ color: 'var(--magenta)', marginBottom: 16, fontSize: '1.2rem' }}>üßÆ Calcule !</p>
                        <Card style={{ textAlign: 'center' }}>
                            <p style={{ fontSize: '1.5rem', fontFamily: 'var(--font-mono)' }}>{Math.floor(Math.random() * 50) + 10} + {Math.floor(Math.random() * 30) + 5} = ?</p>
                            <p style={{ color: 'var(--text-muted)', marginTop: 10, fontSize: '0.85rem' }}>(distraction intentionnelle)</p>
                        </Card>
                    </>
                )}
                {phase === 'recall' && (
                    <>
                        <p style={{ color: 'var(--text-secondary)', marginBottom: 16 }}>S√©lectionne les mots m√©moris√©s :</p>
                        <div style={{ display: 'flex', flexWrap: 'wrap', gap: 10, justifyContent: 'center', maxWidth: 400, marginBottom: 20 }}>
                            {options.map((w, i) => (
                                <button key={i} onClick={() => toggleWord(w)} disabled={!!feedback} className={selected.includes(w) ? 'glass' : ''} style={{
                                    padding: '10px 16px', borderRadius: 10, border: selected.includes(w) ? '2px solid var(--cyan)' : '2px solid transparent',
                                    background: selected.includes(w) ? 'rgba(0,255,213,0.1)' : 'var(--bg-card)', color: 'var(--text-primary)', cursor: 'pointer'
                                }}>{w}</button>
                            ))}
                        </div>
                        <button className="btn btn-primary" onClick={handleSubmit} disabled={selected.length === 0 || !!feedback}>Valider ({selected.length})</button>
                    </>
                )}
                {feedback && <Feedback type={feedback} message={feedback === 'success' ? 'Parfait !' : feedback === 'info' ? 'Partiel' : 'Rat√© !'} />}
            </div>
        </div>
    );
};

// ===== GAME: SYNTAX PUZZLE =====
const SyntaxGame = ({ onBack }) => {
    const [phase, setPhase] = useState('playing');
    const [current, setCurrent] = useState(null);
    const [shuffled, setShuffled] = useState([]);
    const [selected, setSelected] = useState([]);
    const [round, setRound] = useState(0);
    const [score, setScore] = useState(0);
    const [lives, setLives] = useState(3);
    const [feedback, setFeedback] = useState(null);
    const maxRounds = 3;

    const next = useCallback(() => {
        const data = SYNTAX_DATA[round % SYNTAX_DATA.length];
        setCurrent(data); setShuffled(shuffle([...data.fragments])); setSelected([]); setFeedback(null);
    }, [round]);

    useEffect(() => { next(); }, []);

    const handleSelect = (frag, idx) => {
        if (selected.some(s => s.idx === idx)) return;
        const newSel = [...selected, { frag, idx }]; setSelected(newSel);
        if (newSel.length === current.fragments.length) {
            const userSentence = newSel.map(s => s.frag).join(' ').toLowerCase();
            const correctSentence = current.correct.map(i => current.fragments[i]).join(' ').toLowerCase();
            if (userSentence === correctSentence) {
                setFeedback('success'); setScore(s => s + 40);
                setTimeout(() => { if (round + 1 >= maxRounds) setPhase('result'); else { setRound(r => r + 1); next(); } }, 1500);
            } else {
                setFeedback('error'); setLives(l => l - 1);
                if (lives <= 1) setTimeout(() => setPhase('result'), 1000);
                else setTimeout(() => { next(); }, 2000);
            }
        }
    };

    if (phase === 'result') return <ResultScreen score={score} maxScore={maxRounds * 40} onRetry={() => { setRound(0); setScore(0); setLives(3); next(); setPhase('playing'); }} onBack={onBack} />;

    return (
        <div style={{ minHeight: '100vh', display: 'flex', flexDirection: 'column' }}>
            <Header title="Puzzle Syntaxique" onBack={onBack} lives={lives} score={score} progress={(round / maxRounds) * 100} />
            <div style={{ flex: 1, display: 'flex', flexDirection: 'column', padding: 20 }}>
                {selected.length > 0 && <div className="glass" style={{ padding: 16, marginBottom: 16 }}><p style={{ color: 'var(--cyan)', fontSize: '1.1rem' }}>{selected.map(s => s.frag).join(' ')}</p></div>}
                <p style={{ color: 'var(--text-secondary)', marginBottom: 12, textAlign: 'center' }}>Clique dans le bon ordre :</p>
                <div style={{ display: 'flex', flexWrap: 'wrap', gap: 10, justifyContent: 'center' }}>
                    {shuffled.map((frag, i) => {
                        const isUsed = selected.some(s => s.idx === i);
                        return <button key={i} onClick={() => handleSelect(frag, i)} disabled={isUsed || !!feedback} style={{ padding: '12px 18px', borderRadius: 10, border: 'none', background: isUsed ? 'var(--bg-elevated)' : 'var(--bg-card)', color: isUsed ? 'var(--text-muted)' : 'var(--text-primary)', cursor: isUsed ? 'default' : 'pointer', opacity: isUsed ? 0.4 : 1 }}>{frag}</button>;
                    })}
                </div>
                {selected.length > 0 && !feedback && <button className="btn btn-ghost" onClick={() => setSelected([])} style={{ marginTop: 16, alignSelf: 'center' }}>‚Ü∫ Reset</button>}
                {feedback && <Feedback type={feedback} message={feedback === 'success' ? 'Correct !' : 'Mauvais ordre'} />}
            </div>
        </div>
    );
};

// ===== GAME: CLICHE =====
const ClicheGame = ({ onBack }) => {
    const [phase, setPhase] = useState('playing');
    const [current, setCurrent] = useState(null);
    const [round, setRound] = useState(0);
    const [score, setScore] = useState(0);
    const [lives, setLives] = useState(3);
    const [feedback, setFeedback] = useState(null);
    const maxRounds = 5;

    const next = useCallback(() => { setCurrent(CLICHE_DATA[round % CLICHE_DATA.length]); setFeedback(null); }, [round]);
    useEffect(() => { next(); }, []);

    const handleAnswer = (hasCliche) => {
        const correct = hasCliche === current.hasCliche;
        if (correct) { setFeedback('success'); setScore(s => s + 25); setTimeout(() => { if (round + 1 >= maxRounds) setPhase('result'); else { setRound(r => r + 1); next(); } }, 1500); }
        else { setFeedback('error'); setLives(l => l - 1); if (lives <= 1) setTimeout(() => setPhase('result'), 1000); else setTimeout(() => { setRound(r => r + 1); next(); }, 2000); }
    };

    if (phase === 'result') return <ResultScreen score={score} maxScore={maxRounds * 25} onRetry={() => { setRound(0); setScore(0); setLives(3); next(); setPhase('playing'); }} onBack={onBack} />;

    return (
        <div style={{ minHeight: '100vh', display: 'flex', flexDirection: 'column' }}>
            <Header title="Langue Pure" subtitle="D√©tecte les clich√©s IA" onBack={onBack} lives={lives} score={score} progress={(round / maxRounds) * 100} />
            <div style={{ flex: 1, display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', padding: 20 }}>
                {current && (
                    <>
                        <Card style={{ maxWidth: 500 }}><p style={{ fontSize: '1.1rem', lineHeight: 1.7 }}>{current.text}</p>
                            {feedback === 'error' && current.hasCliche && <div style={{ marginTop: 12, padding: 10, background: 'rgba(239,68,68,0.1)', borderRadius: 8 }}><p style={{ color: 'var(--red)', fontSize: '0.85rem' }}>Clich√©s : {current.cliches.join(', ')}</p></div>}
                        </Card>
                        <p style={{ color: 'var(--text-secondary)', margin: '20px 0 12px' }}>Ce texte contient-il des expressions clich√©s d'IA ?</p>
                        <div style={{ display: 'flex', gap: 12 }}>
                            <button className="btn btn-secondary" onClick={() => handleAnswer(false)} disabled={!!feedback} style={{ minWidth: 120, background: 'rgba(34,197,94,0.1)', borderColor: 'var(--green)', color: 'var(--green)' }}>‚úì Naturel</button>
                            <button className="btn btn-secondary" onClick={() => handleAnswer(true)} disabled={!!feedback} style={{ minWidth: 120, background: 'rgba(239,68,68,0.1)', borderColor: 'var(--red)', color: 'var(--red)' }}>‚úó Clich√© IA</button>
                        </div>
                    </>
                )}
                {feedback && <Feedback type={feedback} message={feedback === 'success' ? 'Bien vu !' : 'Rat√© !'} />}
            </div>
        </div>
    );
};

// ===== GAME: METAPHOR =====
const MetaphorGame = ({ onBack }) => {
    const [phase, setPhase] = useState('playing');
    const [current, setCurrent] = useState(null);
    const [round, setRound] = useState(0);
    const [score, setScore] = useState(0);
    const [lives, setLives] = useState(3);
    const [feedback, setFeedback] = useState(null);
    const maxRounds = 4;

    const next = useCallback(() => { setCurrent(METAPHOR_DATA[round % METAPHOR_DATA.length]); setFeedback(null); }, [round]);
    useEffect(() => { next(); }, []);

    const handleAnswer = (idx) => {
        const correct = idx === current.best;
        if (correct) { setFeedback('success'); setScore(s => s + 35); setTimeout(() => { if (round + 1 >= maxRounds) setPhase('result'); else { setRound(r => r + 1); next(); } }, 1200); }
        else { setFeedback('error'); setLives(l => l - 1); if (lives <= 1) setTimeout(() => setPhase('result'), 1000); else setTimeout(() => { setRound(r => r + 1); next(); }, 1500); }
    };

    if (phase === 'result') return <ResultScreen score={score} maxScore={maxRounds * 35} onRetry={() => { setRound(0); setScore(0); setLives(3); next(); setPhase('playing'); }} onBack={onBack} />;

    return (
        <div style={{ minHeight: '100vh', display: 'flex', flexDirection: 'column' }}>
            <Header title="M√©taphores" subtitle="Choisis la meilleure" onBack={onBack} lives={lives} score={score} progress={(round / maxRounds) * 100} />
            <div style={{ flex: 1, display: 'flex', flexDirection: 'column', padding: 20 }}>
                {current && (
                    <>
                        <Card style={{ textAlign: 'center' }}><p style={{ fontSize: '1.3rem', color: 'var(--yellow)', fontWeight: 600 }}>{current.concept}</p><p style={{ color: 'var(--text-muted)', marginTop: 8 }}>c'est comme...</p></Card>
                        <div style={{ display: 'flex', flexDirection: 'column', gap: 10, marginTop: 20, padding: '0 20px' }}>
                            {current.options.map((opt, i) => <OptionBtn key={i} onClick={() => handleAnswer(i)} disabled={!!feedback} correct={feedback && i === current.best} wrong={feedback === 'error' && i !== current.best}>{opt}</OptionBtn>)}
                        </div>
                    </>
                )}
                {feedback && <Feedback type={feedback} message={feedback === 'success' ? 'Excellente m√©taphore !' : `Meilleure : ${current.options[current.best]}`} />}
            </div>
        </div>
    );
};

// ===== GAME: SEQUENCING =====
const SequencingGame = ({ onBack }) => {
    const [phase, setPhase] = useState('playing');
    const [current, setCurrent] = useState(null);
    const [shuffled, setShuffled] = useState([]);
    const [selected, setSelected] = useState([]);
    const [round, setRound] = useState(0);
    const [score, setScore] = useState(0);
    const [lives, setLives] = useState(3);
    const [feedback, setFeedback] = useState(null);
    const maxRounds = 4;

    const next = useCallback(() => {
        const data = SEQUENCE_DATA[round % SEQUENCE_DATA.length];
        setCurrent(data); setShuffled(shuffle([...data.steps])); setSelected([]); setFeedback(null);
    }, [round]);

    useEffect(() => { next(); }, []);

    const handleSelect = (step) => {
        if (selected.includes(step)) return;
        const newSel = [...selected, step]; setSelected(newSel);
        if (newSel.length === current.steps.length) {
            const correct = newSel.every((s, i) => s === current.steps[i]);
            if (correct) { setFeedback('success'); setScore(s => s + 45); setTimeout(() => { if (round + 1 >= maxRounds) setPhase('result'); else { setRound(r => r + 1); next(); } }, 1500); }
            else { setFeedback('error'); setLives(l => l - 1); if (lives <= 1) setTimeout(() => setPhase('result'), 1000); else setTimeout(() => { next(); }, 2000); }
        }
    };

    if (phase === 'result') return <ResultScreen score={score} maxScore={maxRounds * 45} onRetry={() => { setRound(0); setScore(0); setLives(3); next(); setPhase('playing'); }} onBack={onBack} />;

    return (
        <div style={{ minHeight: '100vh', display: 'flex', flexDirection: 'column' }}>
            <Header title="Remets dans l'ordre" subtitle={current?.title} onBack={onBack} lives={lives} score={score} progress={(round / maxRounds) * 100} />
            <div style={{ flex: 1, display: 'flex', flexDirection: 'column', padding: 20 }}>
                {selected.length > 0 && (
                    <div style={{ marginBottom: 16 }}>
                        {selected.map((s, i) => <div key={i} className="glass" style={{ padding: '10px 14px', marginBottom: 6, borderRadius: 10, display: 'flex', alignItems: 'center', gap: 10 }}><span style={{ color: 'var(--cyan)', fontWeight: 700 }}>{i + 1}</span><span>{s}</span></div>)}
                    </div>
                )}
                <div style={{ display: 'flex', flexDirection: 'column', gap: 8 }}>
                    {shuffled.filter(s => !selected.includes(s)).map((step, i) => <OptionBtn key={i} onClick={() => handleSelect(step)} disabled={!!feedback}>{step}</OptionBtn>)}
                </div>
                {selected.length > 0 && !feedback && <button className="btn btn-ghost" onClick={() => setSelected([])} style={{ marginTop: 12, alignSelf: 'center' }}>‚Ü∫ Reset</button>}
                {feedback && <Feedback type={feedback} message={feedback === 'success' ? 'Ordre parfait !' : 'Mauvais ordre'} />}
            </div>
        </div>
    );
};

// ===== GAME: RESOURCES =====
const ResourcesGame = ({ onBack }) => {
    const [phase, setPhase] = useState('playing');
    const [selected, setSelected] = useState([]);
    const [round, setRound] = useState(0);
    const [score, setScore] = useState(0);
    const [feedback, setFeedback] = useState(null);
    const scenarios = [
        { title: "Lancement produit", resources: { budget: 100, temps: 10 }, objectives: [
            { name: "Marketing viral", cost: { budget: 40, temps: 3 }, value: 30 },
            { name: "Am√©liorer produit", cost: { budget: 30, temps: 5 }, value: 40 },
            { name: "Support client", cost: { budget: 20, temps: 4 }, value: 25 },
            { name: "Partenariats", cost: { budget: 35, temps: 6 }, value: 35 }
        ]},
        { title: "Week-end productif", resources: { energie: 100, heures: 16 }, objectives: [
            { name: "Sport", cost: { energie: 30, heures: 2 }, value: 35 },
            { name: "Side project", cost: { energie: 40, heures: 6 }, value: 45 },
            { name: "Repos", cost: { energie: -20, heures: 4 }, value: 25 },
            { name: "Socialiser", cost: { energie: 25, heures: 4 }, value: 30 }
        ]}
    ];
    const current = scenarios[round % scenarios.length];

    const remaining = Object.keys(current.resources).reduce((acc, key) => {
        acc[key] = current.resources[key] - selected.reduce((sum, idx) => sum + (current.objectives[idx].cost[key] || 0), 0);
        return acc;
    }, {});

    const canSelect = (idx) => {
        if (selected.includes(idx)) return false;
        const obj = current.objectives[idx];
        return Object.keys(obj.cost).every(key => remaining[key] >= obj.cost[key]);
    };

    const totalValue = selected.reduce((sum, idx) => sum + current.objectives[idx].value, 0);

    const handleSelect = (idx) => {
        if (!canSelect(idx)) return;
        setSelected([...selected, idx]);
    };

    const handleSubmit = () => {
        const maxPossible = Math.max(...current.objectives.map(o => o.value)) * 2;
        const pct = totalValue / maxPossible;
        if (pct >= 0.7) { setFeedback('success'); setScore(s => s + totalValue); }
        else { setFeedback('info'); setScore(s => s + Math.floor(totalValue * 0.5)); }
        setTimeout(() => { if (round + 1 >= scenarios.length) setPhase('result'); else { setRound(r => r + 1); setSelected([]); setFeedback(null); } }, 1500);
    };

    if (phase === 'result') return <ResultScreen score={score} onRetry={() => { setRound(0); setScore(0); setSelected([]); setPhase('playing'); }} onBack={onBack} />;

    return (
        <div style={{ minHeight: '100vh', display: 'flex', flexDirection: 'column' }}>
            <Header title="Gestionnaire" subtitle={current.title} onBack={onBack} score={score} progress={(round / scenarios.length) * 100} />
            <div style={{ flex: 1, display: 'flex', flexDirection: 'column', padding: 20 }}>
                <div className="glass" style={{ padding: 16, marginBottom: 16, display: 'flex', justifyContent: 'space-around' }}>
                    {Object.entries(remaining).map(([key, val]) => (
                        <div key={key} style={{ textAlign: 'center' }}>
                            <div style={{ fontSize: '1.5rem', fontWeight: 700, color: val < 0 ? 'var(--red)' : 'var(--cyan)' }}>{val}</div>
                            <div style={{ fontSize: '0.75rem', color: 'var(--text-muted)', textTransform: 'capitalize' }}>{key}</div>
                        </div>
                    ))}
                    <div style={{ textAlign: 'center', borderLeft: '1px solid rgba(255,255,255,0.1)', paddingLeft: 16 }}>
                        <div style={{ fontSize: '1.5rem', fontWeight: 700, color: 'var(--yellow)' }}>{totalValue}</div>
                        <div style={{ fontSize: '0.75rem', color: 'var(--text-muted)' }}>Valeur</div>
                    </div>
                </div>
                
                <div style={{ display: 'flex', flexDirection: 'column', gap: 10 }}>
                    {current.objectives.map((obj, i) => (
                        <button key={i} onClick={() => handleSelect(i)} disabled={!canSelect(i) || !!feedback} style={{
                            padding: '14px 18px', borderRadius: 'var(--radius-md)', border: selected.includes(i) ? '2px solid var(--cyan)' : '2px solid transparent',
                            background: selected.includes(i) ? 'rgba(0,255,213,0.1)' : canSelect(i) ? 'var(--bg-card)' : 'var(--bg-elevated)',
                            opacity: canSelect(i) || selected.includes(i) ? 1 : 0.5, textAlign: 'left', cursor: canSelect(i) ? 'pointer' : 'default'
                        }}>
                            <div style={{ fontWeight: 600, marginBottom: 4 }}>{obj.name}</div>
                            <div style={{ fontSize: '0.85rem', color: 'var(--text-muted)' }}>
                                {Object.entries(obj.cost).map(([k, v]) => `${k}: ${v > 0 ? '-' : '+'}${Math.abs(v)}`).join(' | ')} ‚Üí <span style={{ color: 'var(--yellow)' }}>+{obj.value} pts</span>
                            </div>
                        </button>
                    ))}
                </div>
                
                <button className="btn btn-primary" onClick={handleSubmit} disabled={selected.length === 0 || !!feedback} style={{ marginTop: 20 }}>Valider ma s√©lection</button>
                {feedback && <Feedback type={feedback} message={feedback === 'success' ? 'Excellente allocation !' : 'Pas optimal, mais OK'} />}
            </div>
        </div>
    );
};

// ===== GAME: ASSOCIATIONS =====
const AssociationsGame = ({ onBack }) => {
    const [phase, setPhase] = useState('playing');
    const [current, setCurrent] = useState(null);
    const [round, setRound] = useState(0);
    const [score, setScore] = useState(0);
    const [lives, setLives] = useState(3);
    const [selected, setSelected] = useState(null);
    const [feedback, setFeedback] = useState(null);
    const maxRounds = 4;

    const next = useCallback(() => { setCurrent(ASSOCIATION_DATA[round % ASSOCIATION_DATA.length]); setSelected(null); setFeedback(null); }, [round]);
    useEffect(() => { next(); }, []);

    const handleSelect = (link) => {
        setSelected(link); setFeedback('success'); setScore(s => s + 40);
        setTimeout(() => { if (round + 1 >= maxRounds) setPhase('result'); else { setRound(r => r + 1); next(); } }, 1500);
    };

    if (phase === 'result') return <ResultScreen score={score} maxScore={maxRounds * 40} onRetry={() => { setRound(0); setScore(0); setLives(3); next(); setPhase('playing'); }} onBack={onBack} />;

    return (
        <div style={{ minHeight: '100vh', display: 'flex', flexDirection: 'column' }}>
            <Header title="Connexions Improbables" onBack={onBack} score={score} progress={(round / maxRounds) * 100} />
            <div style={{ flex: 1, display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', padding: 20 }}>
                {current && (
                    <>
                        <div style={{ display: 'flex', alignItems: 'center', gap: 20, marginBottom: 24 }}>
                            <div className="glass" style={{ padding: '20px 30px', borderRadius: 'var(--radius-lg)' }}><span style={{ fontSize: '1.5rem', fontWeight: 700, color: 'var(--cyan)' }}>{current.word1}</span></div>
                            <span style={{ fontSize: '2rem', color: 'var(--text-muted)' }}>üîó</span>
                            <div className="glass" style={{ padding: '20px 30px', borderRadius: 'var(--radius-lg)' }}><span style={{ fontSize: '1.5rem', fontWeight: 700, color: 'var(--magenta)' }}>{current.word2}</span></div>
                        </div>
                        <p style={{ color: 'var(--text-secondary)', marginBottom: 16 }}>Quel lien te semble le plus pertinent ?</p>
                        <div style={{ display: 'flex', flexDirection: 'column', gap: 10, width: '100%', maxWidth: 400 }}>
                            {current.links.map((link, i) => <OptionBtn key={i} onClick={() => handleSelect(link)} disabled={!!feedback} correct={feedback && selected === link}>{link}</OptionBtn>)}
                        </div>
                    </>
                )}
                {feedback && <Feedback type="success" message="Connexion cr√©ative valid√©e !" />}
            </div>
        </div>
    );
};

// ===== GAME: UCHRONIA =====
const UchroniaGame = ({ onBack }) => {
    const [phase, setPhase] = useState('playing');
    const [current, setCurrent] = useState(null);
    const [round, setRound] = useState(0);
    const [score, setScore] = useState(0);
    const [lives, setLives] = useState(3);
    const [feedback, setFeedback] = useState(null);
    const maxRounds = 3;

    const next = useCallback(() => { setCurrent(UCHRONIA_DATA[round % UCHRONIA_DATA.length]); setFeedback(null); }, [round]);
    useEffect(() => { next(); }, []);

    const handleAnswer = (consequence) => {
        const isAbsurd = consequence === current.absurd;
        if (!isAbsurd) { setFeedback('success'); setScore(s => s + 35); setTimeout(() => { if (round + 1 >= maxRounds) setPhase('result'); else { setRound(r => r + 1); next(); } }, 1200); }
        else { setFeedback('error'); setLives(l => l - 1); if (lives <= 1) setTimeout(() => setPhase('result'), 1000); else setTimeout(() => { setRound(r => r + 1); next(); }, 1500); }
    };

    if (phase === 'result') return <ResultScreen score={score} maxScore={maxRounds * 35} onRetry={() => { setRound(0); setScore(0); setLives(3); next(); setPhase('playing'); }} onBack={onBack} />;

    const options = current ? shuffle([...current.consequences.slice(0, 3), current.absurd]) : [];

    return (
        <div style={{ minHeight: '100vh', display: 'flex', flexDirection: 'column' }}>
            <Header title="Et si... ?" onBack={onBack} lives={lives} score={score} progress={(round / maxRounds) * 100} />
            <div style={{ flex: 1, display: 'flex', flexDirection: 'column', padding: 20 }}>
                {current && (
                    <>
                        <Card style={{ textAlign: 'center', marginBottom: 20 }}><p style={{ fontSize: '1.3rem', color: 'var(--purple)', fontWeight: 600 }}>{current.scenario}</p></Card>
                        <p style={{ color: 'var(--text-secondary)', marginBottom: 12, textAlign: 'center' }}>Quelle cons√©quence est ABSURDE ?</p>
                        <div style={{ display: 'flex', flexDirection: 'column', gap: 10 }}>
                            {options.map((opt, i) => <OptionBtn key={i} onClick={() => handleAnswer(opt)} disabled={!!feedback} correct={feedback === 'success' && opt !== current.absurd} wrong={feedback === 'error' && opt === current.absurd}>{opt}</OptionBtn>)}
                        </div>
                    </>
                )}
                {feedback && <Feedback type={feedback} message={feedback === 'success' ? 'Bien raisonn√© !' : 'C\'√©tait l\'absurde !'} />}
            </div>
        </div>
    );
};

// ===== GAME: REACTION (Go/No-Go) =====
const ReactionGame = ({ onBack }) => {
    const [phase, setPhase] = useState('ready');
    const [target, setTarget] = useState('green');
    const [current, setCurrent] = useState(null);
    const [score, setScore] = useState(0);
    const [lives, setLives] = useState(3);
    const [round, setRound] = useState(0);
    const [feedback, setFeedback] = useState(null);
    const [reactionTimes, setReactionTimes] = useState([]);
    const [showTime, setShowTime] = useState(0);
    const maxRounds = 20;

    const showStimulus = useCallback(() => {
        const isTarget = Math.random() < 0.7;
        const color = isTarget ? 'green' : pick(['red', 'yellow', 'blue']);
        setCurrent(color); setShowTime(Date.now()); setPhase('stimulus');
        setTimeout(() => { if (phase === 'stimulus') { setFeedback(color === target ? 'error' : null); if (color === target) setLives(l => l - 1); nextRound(); } }, 1500);
    }, [target, phase]);

    const nextRound = () => {
        if (round + 1 >= maxRounds || lives <= 1) { setPhase('result'); return; }
        setRound(r => r + 1); setFeedback(null); setCurrent(null);
        setTimeout(showStimulus, 500 + Math.random() * 1000);
    };

    useEffect(() => { if (phase === 'ready') { const t = setTimeout(showStimulus, 1000); return () => clearTimeout(t); } }, [phase]);

    const handleTap = () => {
        if (phase !== 'stimulus') return;
        const rt = Date.now() - showTime;
        if (current === target) {
            setReactionTimes(t => [...t, rt]); setScore(s => s + Math.max(10, 50 - Math.floor(rt / 20))); setFeedback('success');
        } else {
            setLives(l => l - 1); setFeedback('error');
        }
        setTimeout(nextRound, 500);
    };

    const avgRT = reactionTimes.length > 0 ? Math.round(reactionTimes.reduce((a, b) => a + b, 0) / reactionTimes.length) : 0;

    if (phase === 'result') return <ResultScreen score={score} stats={{ "Temps moyen": `${avgRT}ms`, Pr√©cision: `${Math.round((reactionTimes.length / round) * 100)}%` }} onRetry={() => { setPhase('ready'); setScore(0); setLives(3); setRound(0); setReactionTimes([]); }} onBack={onBack} />;

    const colorMap = { green: 'var(--green)', red: 'var(--red)', yellow: 'var(--yellow)', blue: 'var(--blue)' };

    return (
        <div style={{ minHeight: '100vh', display: 'flex', flexDirection: 'column' }} onClick={handleTap}>
            <Header title="Go / No-Go" subtitle="Tape sur VERT seulement" onBack={onBack} lives={lives} score={score} progress={(round / maxRounds) * 100} />
            <div style={{ flex: 1, display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', padding: 20 }}>
                {current ? (
                    <div className={feedback === 'error' ? 'shake' : feedback === 'success' ? 'pulse' : ''} style={{ width: 150, height: 150, borderRadius: '50%', background: colorMap[current], boxShadow: `0 0 60px ${colorMap[current]}66`, transition: 'all 0.2s ease' }} />
                ) : (
                    <p style={{ color: 'var(--text-muted)' }}>Pr√©pare-toi...</p>
                )}
                <p style={{ color: 'var(--text-secondary)', marginTop: 30 }}>Tape sur <span style={{ color: 'var(--green)', fontWeight: 700 }}>VERT</span>, ignore les autres</p>
            </div>
        </div>
    );
};

// ===== GAME: FOCUS =====
const FocusGame = ({ onBack }) => {
    const [phase, setPhase] = useState('playing');
    const [grid, setGrid] = useState([]);
    const [changedIdx, setChangedIdx] = useState(-1);
    const [score, setScore] = useState(0);
    const [lives, setLives] = useState(3);
    const [level, setLevel] = useState(1);
    const [round, setRound] = useState(0);
    const [showChange, setShowChange] = useState(false);
    const [feedback, setFeedback] = useState(null);
    const maxRounds = 10;

    const genGrid = useCallback(() => {
        const size = 3 + Math.floor(level / 3);
        const g = Array.from({ length: size * size }, () => pick(COLORS));
        setGrid(g); setChangedIdx(-1); setShowChange(false); setFeedback(null);
        setTimeout(() => {
            const idx = Math.floor(Math.random() * g.length);
            const newColor = pick(COLORS.filter(c => c !== g[idx]));
            const newGrid = [...g]; newGrid[idx] = newColor;
            setGrid(newGrid); setChangedIdx(idx); setShowChange(true);
        }, 2000 + level * 200);
    }, [level]);

    useEffect(() => { genGrid(); }, []);

    const handleClick = (idx) => {
        if (!showChange || feedback) return;
        if (idx === changedIdx) {
            setFeedback('success'); setScore(s => s + level * 15);
            setTimeout(() => { if (round + 1 >= maxRounds) { setLevel(l => l + 1); setRound(0); } else setRound(r => r + 1); genGrid(); }, 800);
        } else {
            setFeedback('error'); setLives(l => l - 1);
            if (lives <= 1) setTimeout(() => setPhase('result'), 500);
            else setTimeout(() => { genGrid(); }, 1000);
        }
    };

    if (phase === 'result') return <ResultScreen score={score} level={level} onRetry={() => { setLevel(1); setRound(0); setScore(0); setLives(3); genGrid(); setPhase('playing'); }} onBack={onBack} />;

    const size = Math.sqrt(grid.length);

    return (
        <div style={{ minHeight: '100vh', display: 'flex', flexDirection: 'column' }}>
            <Header title="Focus Soutenu" subtitle="Trouve ce qui a chang√©" onBack={onBack} lives={lives} score={score} level={level} />
            <div style={{ flex: 1, display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', padding: 20 }}>
                <div className={feedback === 'error' ? 'shake' : ''} style={{ display: 'grid', gridTemplateColumns: `repeat(${size}, 1fr)`, gap: 8 }}>
                    {grid.map((c, i) => (
                        <button key={i} onClick={() => handleClick(i)} disabled={!showChange || !!feedback} style={{
                            width: 60, height: 60, borderRadius: 10, border: feedback && i === changedIdx ? '3px solid white' : 'none',
                            background: COLOR_HEX[c], cursor: showChange ? 'pointer' : 'default', transition: 'all 0.2s ease'
                        }} />
                    ))}
                </div>
                <p style={{ color: 'var(--text-muted)', marginTop: 20 }}>{showChange ? 'Clique sur la case qui a chang√© !' : 'Observe attentivement...'}</p>
                {feedback && <Feedback type={feedback} message={feedback === 'success' ? 'Trouv√© !' : 'Mauvaise case'} />}
            </div>
        </div>
    );
};

// ===== GAME: CONSTRAINTS =====
const ConstraintsGame = ({ onBack }) => {
    const [phase, setPhase] = useState('playing');
    const [round, setRound] = useState(0);
    const [score, setScore] = useState(0);
    const [lives, setLives] = useState(3);
    const [feedback, setFeedback] = useState(null);
    const maxRounds = 4;

    const challenges = [
        { task: "Construis une phrase avec ces 3 mots", words: ["soleil", "myst√®re", "courir"], options: [
            "Le soleil cache un myst√®re que je veux d√©couvrir en courant",
            "Courir myst√®re soleil dans",
            "Le myst√®re du soleil me fait courir vers lui",
            "Soleil courir myst√®re phrase"
        ], correct: [0, 2] },
        { task: "Choisis la phrase qui utilise TOUS ces mots", words: ["nuage", "pens√©e", "danser"], options: [
            "Ma pens√©e danse comme un nuage",
            "Le nuage pense √† danser",
            "Danser sous les nuages de pens√©es",
            "Pens√©e nuage"
        ], correct: [0, 1, 2] },
        { task: "Quelle phrase respecte l'ordre des mots ?", words: ["avant", "apr√®s", "pendant"], options: [
            "Avant de manger, pendant le film, apr√®s le travail",
            "Pendant le repas, apr√®s la sieste, avant minuit",
            "Apr√®s tout, avant peu, pendant ce temps",
            "Avant apr√®s pendant"
        ], correct: [0, 2] }
    ];

    const current = challenges[round % challenges.length];

    const handleAnswer = (idx) => {
        const correct = current.correct.includes(idx);
        if (correct) { setFeedback('success'); setScore(s => s + 30); setTimeout(() => { if (round + 1 >= maxRounds) setPhase('result'); else { setRound(r => r + 1); setFeedback(null); } }, 1200); }
        else { setFeedback('error'); setLives(l => l - 1); if (lives <= 1) setTimeout(() => setPhase('result'), 1000); else setTimeout(() => { setRound(r => r + 1); setFeedback(null); }, 1500); }
    };

    if (phase === 'result') return <ResultScreen score={score} maxScore={maxRounds * 30} onRetry={() => { setRound(0); setScore(0); setLives(3); setFeedback(null); setPhase('playing'); }} onBack={onBack} />;

    return (
        <div style={{ minHeight: '100vh', display: 'flex', flexDirection: 'column' }}>
            <Header title="Contraintes" onBack={onBack} lives={lives} score={score} progress={(round / maxRounds) * 100} />
            <div style={{ flex: 1, display: 'flex', flexDirection: 'column', padding: 20 }}>
                <Card style={{ textAlign: 'center', marginBottom: 16 }}>
                    <p style={{ color: 'var(--text-secondary)', marginBottom: 12 }}>{current.task}</p>
                    <div style={{ display: 'flex', gap: 10, justifyContent: 'center', flexWrap: 'wrap' }}>
                        {current.words.map((w, i) => <span key={i} style={{ padding: '8px 14px', background: 'var(--bg-elevated)', borderRadius: 8, color: 'var(--yellow)', fontWeight: 600 }}>{w}</span>)}
                    </div>
                </Card>
                <div style={{ display: 'flex', flexDirection: 'column', gap: 10 }}>
                    {current.options.map((opt, i) => <OptionBtn key={i} onClick={() => handleAnswer(i)} disabled={!!feedback} correct={feedback && current.correct.includes(i)} wrong={feedback === 'error' && !current.correct.includes(i)}>{opt}</OptionBtn>)}
                </div>
                {feedback && <Feedback type={feedback} message={feedback === 'success' ? 'Correct !' : 'Pas valide'} />}
            </div>
        </div>
    );
};

// ===== NAVIGATION SCREENS =====

const HomeScreen = ({ onSelectCategory, userData }) => {
    const streak = userData?.streak || 0;
    const totalScore = userData?.totalScore || 0;
    
    return (
        <div style={{ minHeight: '100vh', padding: '20px 20px 40px' }}>
            <div style={{ textAlign: 'center', marginBottom: 30, paddingTop: 20 }}>
                <h1 className="gradient-text" style={{ fontSize: '2.5rem', fontWeight: 900, marginBottom: 8 }}>Neural Streak</h1>
                <p style={{ color: 'var(--text-secondary)' }}>R√©entra√Æne ton cerveau</p>
                
                {streak > 0 && (
                    <div className="glass fadeIn" style={{ display: 'inline-flex', gap: 24, padding: '12px 24px', borderRadius: 'var(--radius-lg)', marginTop: 16 }}>
                        <div style={{ textAlign: 'center' }}>
                            <div style={{ fontSize: '1.5rem', fontWeight: 700, color: 'var(--orange)' }}>üî• {streak}</div>
                            <div style={{ fontSize: '0.7rem', color: 'var(--text-muted)' }}>STREAK</div>
                        </div>
                        <div style={{ textAlign: 'center' }}>
                            <div style={{ fontSize: '1.5rem', fontWeight: 700, color: 'var(--yellow)' }}>{totalScore}</div>
                            <div style={{ fontSize: '0.7rem', color: 'var(--text-muted)' }}>TOTAL</div>
                        </div>
                    </div>
                )}
            </div>
            
            <div style={{ display: 'flex', flexDirection: 'column', gap: 12 }}>
                {CATEGORIES.map((cat, i) => (
                    <button key={cat.id} onClick={() => onSelectCategory(cat)} className="card fadeIn" style={{
                        padding: 20, textAlign: 'left', border: 'none', cursor: 'pointer',
                        background: 'var(--bg-card)', animationDelay: `${i * 0.05}s`
                    }}>
                        <div style={{ display: 'flex', alignItems: 'center', gap: 16 }}>
                            <div style={{ fontSize: '2.5rem' }}>{cat.icon}</div>
                            <div style={{ flex: 1 }}>
                                <h3 style={{ fontWeight: 700, marginBottom: 4 }}>{cat.name}</h3>
                                <p style={{ fontSize: '0.85rem', color: 'var(--text-muted)', lineHeight: 1.4 }}>{cat.stat} {cat.statDesc}</p>
                            </div>
                            <div style={{ color: 'var(--text-muted)' }}>‚Üí</div>
                        </div>
                    </button>
                ))}
            </div>
            
            <p style={{ textAlign: 'center', color: 'var(--text-muted)', fontSize: '0.75rem', marginTop: 30 }}>
                Bas√© sur MIT Media Lab 2025 & Gerlich 2025
            </p>
        </div>
    );
};

const CategoryScreen = ({ category, onSelectGame, onBack }) => {
    return (
        <div style={{ minHeight: '100vh', display: 'flex', flexDirection: 'column' }}>
            <Header title={category.name} onBack={onBack} />
            
            <div style={{ flex: 1, padding: 20 }}>
                <div className="glass fadeIn" style={{ padding: 20, marginBottom: 24, textAlign: 'center' }}>
                    <div style={{ fontSize: '3rem', marginBottom: 12 }}>{category.icon}</div>
                    <div style={{ fontSize: '2rem', fontWeight: 800, color: 'var(--cyan)' }}>{category.stat}</div>
                    <p style={{ color: 'var(--text-secondary)', fontSize: '0.9rem' }}>{category.statDesc}</p>
                </div>
                
                <h3 style={{ color: 'var(--text-secondary)', fontSize: '0.85rem', marginBottom: 12, textTransform: 'uppercase', letterSpacing: 1 }}>Mini-jeux disponibles</h3>
                
                <div style={{ display: 'flex', flexDirection: 'column', gap: 10 }}>
                    {category.games.map((gameId, i) => {
                        const game = GAMES[gameId];
                        if (!game) return null;
                        return (
                            <button key={gameId} onClick={() => onSelectGame(gameId)} className="card fadeIn" style={{
                                padding: 16, textAlign: 'left', border: 'none', cursor: 'pointer',
                                background: 'var(--bg-card)', display: 'flex', alignItems: 'center', gap: 14,
                                animationDelay: `${i * 0.05}s`
                            }}>
                                <div style={{ fontSize: '1.8rem' }}>{game.icon}</div>
                                <div style={{ flex: 1 }}>
                                    <h4 style={{ fontWeight: 600, marginBottom: 2 }}>{game.name}</h4>
                                    <p style={{ fontSize: '0.8rem', color: 'var(--text-muted)' }}>{game.desc}</p>
                                </div>
                                <div style={{ color: 'var(--text-muted)' }}>‚ñ∂</div>
                            </button>
                        );
                    })}
                </div>
            </div>
        </div>
    );
};

// ===== MAIN APP =====
const App = () => {
    const [screen, setScreen] = useState('home');
    const [selectedCategory, setSelectedCategory] = useState(null);
    const [selectedGame, setSelectedGame] = useState(null);
    const [userData, setUserData] = useState(null);

    useEffect(() => {
        const saved = localStorage.getItem('neural_user');
        if (saved) setUserData(JSON.parse(saved));
    }, [screen]);

    const handleSelectCategory = (cat) => {
        setSelectedCategory(cat);
        setScreen('category');
    };

    const handleSelectGame = (gameId) => {
        setSelectedGame(gameId);
        setScreen('game');
    };

    const handleBack = () => {
        if (screen === 'game') {
            setScreen('category');
            setSelectedGame(null);
        } else if (screen === 'category') {
            setScreen('home');
            setSelectedCategory(null);
        }
    };

    const GameComponents = {
        sequence: SequenceGame,
        nback: NBackGame,
        chunking: ChunkingGame,
        updating: UpdatingGame,
        hallucination: HallucinationGame,
        fallacy: FallacyGame,
        trilemma: TrilemmaGame,
        humanai: HumanAIGame,
        causal: CausalGame,
        recall: RecallGame,
        syntax: SyntaxGame,
        cliche: ClicheGame,
        metaphor: MetaphorGame,
        sequencing: SequencingGame,
        resources: ResourcesGame,
        associations: AssociationsGame,
        uchronia: UchroniaGame,
        reaction: ReactionGame,
        focus: FocusGame,
        constraints: ConstraintsGame
    };

    if (screen === 'home') {
        return <HomeScreen onSelectCategory={handleSelectCategory} userData={userData} />;
    }

    if (screen === 'category' && selectedCategory) {
        return <CategoryScreen category={selectedCategory} onSelectGame={handleSelectGame} onBack={handleBack} />;
    }

    if (screen === 'game' && selectedGame) {
        const GameComponent = GameComponents[selectedGame];
        if (GameComponent) {
            return <GameComponent onBack={handleBack} />;
        }
    }

    return <HomeScreen onSelectCategory={handleSelectCategory} userData={userData} />;
};

// ===== RENDER =====
ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
